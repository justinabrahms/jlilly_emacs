\input texinfo   @c -*-mode: texinfo; coding: euc-jp;-*-
@c %**start of header
@setfilename ../info/tramp_ja
@settitle TRAMP User Manual
@setchapternewpage odd
@documentlanguage ja
@documentencoding euc-jp
@c %**end of header

@c XXX This is a euc-jp file. I know it is better to use iso-2022-jp 
@c XXX for htmlizing, but makeinfo doesn't work with it. 
@c XXX I found the patch for wide-character, but it doesn't seems to 
@c XXX work with iso-2022-jp.
@c XXX http://www02.u-page.so-net.ne.jp/xa2/fukusaka/linux/

@c XXX Notice for Japanese translation
@c XXX I use `@ifset ja' for the contents only in Japanese version and
@c XXX the translator's comment.
@clear ja
@set ja

@c This is *so* much nicer :)
@footnotestyle end

@c In the Tramp CVS, the version number is auto-frobbed from
@c configure.ac, so you should edit that file and run
@c "autoconf && ./configure" to change the version number.
@c XXX VERSION and UPDATED are Japanese manual's version and update date.
@c XXX If we need original's one, we MUST use literal version and date
@c XXX strings.
@c XXX
@c XXX This translation is based on tramp.texi rev. 2.98
@c XXX

@c Additionally, flags are set with respect to the Emacs flavor; and
@c depending whether Tramp is packaged into (X)Emacs, or standalone.

@include trampver.texi

@c Macros for formatting a filename.
@c trampfn is for a full filename, trampfnmhp means method, host, localname
@c were given, and so on.
@macro trampfn(method, user, host, localname)
@value{prefix}@value{method}@value{user}@@@value{host}@value{postfix}@value{localname}
@end macro

@copying
Copyright @copyright{} 1999, 2000, 2001, 2002, 2003 Free Software
Foundation, Inc.

@quotation     
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of the
license is included in the section entitled ``GNU Free Documentation
License'' in the Emacs manual.

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify
this GNU Manual, like GNU software.  Copies published by the Free
Software Foundation raise funds for GNU development.''

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.
@end quotation
@end copying

@c Entries for @command{install-info} to use
@dircategory Emacs
@direntry
* TRAMP-ja: (tramp_ja).          Transparent Remote Access, Multiple Protocol
                                 Emacs remote file access via rsh and rcp
                                 (Japanese).
@end direntry

@tex

@titlepage
@title @value{tramp} version @value{trampver} User Manual

@author by Daniel Pittman
@author based on documentation by Kai Gro@ss{}johann

@page
@insertcopying

@end titlepage
@page

@end tex

@ifnottex
@node Top, Overview, (dir), (dir)
@top @value{tramp} version @value{trampver} ユーザーマニュアル

このファイルは @value{tramp} version @value{trampver} について説明します。
@value{tramp} は @value{emacsname} にリモートファイルの編集機能を提供する
パッケージです。

@value{tramp} は `Transparent Remote (file) Access, Multiple Protocol'
の略称です。このパッケージは @value{ftppackagename} のような
リモートファイルの編集機能を提供します。

異なる点はファイルの転送方法です。@value{ftppackagename} は、
ローカルホストとリモートホスト間のファイル転送に FTP を使用します。
一方 @value{tramp} は、@command{rsh} と @command{rcp} あるいは他の同じよう
な働きをするプログラム、例えば @command{ssh} や @command{scp}を使用し
ます。

このドキュメントの最新バージョンは web サイト
@uref{http://www.freesoftware.fsf.org/tramp/}
にあります。

@c Pointer to the other Emacs flavor is necessary only in case of
@c standalone installation.  Text taken from trampinst.texi.
@ifset installchapter
The manual has been generated for @value{emacsname}.
@ifinfo
If you want to read the info pages for @value{emacsothername}, you
should read in @ref{Installation} how to create them.
@end ifinfo
@ifhtml
If you're using the other Emacs flavour, you should read the
@uref{@value{emacsotherfilename}, @value{emacsothername}} pages.
@end ifhtml
@end ifset

@ifhtml
このマニュアルには @uref{tramp_ja.html, 日本語訳}が存在します。

@ifset ja
[訳注: そう、あなたが読んでいる、これが日本語訳です :-)]
@end ifset

最新の @value{tramp} は
@uref{http://savannah.gnu.org/download/tramp/,download}
にあります。詳細は @ref{Obtaining Tramp} を参照してください。
CVS サーバーについての説明もあります。

また、 @uref{https://savannah.gnu.org/projects/tramp/,
Savannah Project Page} にも @value{tramp} の情報があります。
@end ifhtml

@value{tramp}のためのメーリングリスト @email{tramp-devel@@mail.freesoftware.fsf.org},
が存在します。アーカイブは通常の Savannah アーカイブと同じ場所と、
@uref{http://www.mail-archive.com/emacs-rcp@@ls6.cs.uni-dortmund.de/}
にあります。

@insertcopying

@end ifnottex

@menu
* Overview::                    @value{tramp} で可能な事、不可能な事

エンドユーザー向け:

* Obtaining Tramp::             @value{tramp} の入手方法
* History::                     @value{tramp} の歴史
@ifset installchapter
* Installation::                @value{tramp} のインストール
@end ifset
* Configuration::               @value{tramp} の設定
* Usage::                       @value{tramp} の使い方
* Bug Reports::                 バグや問題の報告
* Frequently Asked Questions::  よくある質問とその答
* Concept Index::               それぞれの概念についての項目

開発者向け:

* Version Control::             リモートバージョンコントロールの内部動作
* Files directories and localnames:: ファイル名、ディレクトリ、ローカル名がどのように
                                変換され(mangled)、管理されるか
* Issues::			議論の余地がある点と何が決定されているか

@detailmenu
 --- 詳細なノードの一覧 ---
@c
@ifset installchapter
あなたの @value{emacsname} に @value{tramp} を導入する

* Installation parameters::     インストールの際のパラメータ
* Load paths::                  あなたの環境に @value{tramp} を組み込む方法

@end ifset

@value{tramp} の設定

* Connection types::            リモートマシンへの接続の種類
* Inline methods::              インラインメソッド
* External transfer methods::   外部転送メソッド
* Multi-hop Methods::           マルチホップを使用したリモートホストへの接続
* Default Method::              デフォルトのメソッドの選択
* Customizing Methods::         非標準のメソッドを使う
* Customizing Completion::      ユーザ／ホスト名補完のための設定ファイルの選択
* Remote Programs::             リモートマシン上で @value{tramp} がプログラムを発見、使用する方法
* Remote shell setup::          リモートシェル設定のヒント
* Windows setup hints::         Cygwin ssh にまつわる事柄
* Auto-save and Backup::        Auto-save とバックアップ

@value{tramp} の使い方

* Filename Syntax::             @value{tramp} ファイル名のきまり
* Multi-hop filename syntax::   マルチホップファイル名のきまり
* Filename completion::         ファイル名の補完
* Dired::                       Dired

リモートバージョンコントロールの内部動作

* Version Controlled Files::    ファイルがバージョン管理されているかどうかの判断
* Remote Commands::             リモートマシン上でのバージョン管理コマンドの実行
* Changed workfiles::           作業ファイルの変更の発見
* Checking out files::          作業ファイルのリポジトリからの取得
* Miscellaneous Version Control::  その他バージョン管理システムに関係する事

その他バージョン管理システムに関係する事

* Remote File Ownership::       VC がワークファイルのオーナーを調べる方法
* Back-end Versions::           VC が RCS のバージョンを調べる方法

ファイル名、ディレクトリ、ローカル名がどのように変換され(mangled)、管理されるか

* Localname deconstruction::    ローカル名の要素への分解

@end detailmenu
@end menu

@node Overview
@chapter @value{tramp} の概要
@cindex overview

@value{emacsname} に @value{tramp} をインストールすると、リモートマシン上
のファイルにローカルファイルと同じような感覚でアクセスできます。
リモートファイルシステム上のファイルの編集、バージョンコントロール、
@command{dired} を透過的に実行することができます。

リモートマシンへのアクセスには、@command{rsh} や @command{rlogin}、
@command{telnet} コマンド、あるいはこれらに類似した接続方法を使用
します。これらのコマンドは ASCII を通過させることが可能でなければ
なりませんが、8-bit クリーンである必要はありません。

このパッケージは別のマシンへの @command{ssh} 接続をサポートします。
これは、このパッケージのもっとも一般的な使い方のひとつです。特に 
@command{ftp}アクセスが許可されていない場合にも、他のマシンへの
比較的セキュアなアクセスが可能となります。

@value{tramp} によって実行されるアクティビティのほとんどは、リモート
ログインが可能で、端末上で実行できることだけを要求します。リモート
ファイルにアクセスするために、@value{tramp} はファイルの内容を一時的
にローカルマシンに転送します。

@value{tramp} は、さまざまな方法でマシン間のファイル転送をおこないます。
転送方法は簡単に選択でき、あなたのニーズとマシン環境に応じて使い
わける事ができます。

(大きなファイルに対して)もっとも速い転送メソッドは、リモートファイルの
転送パッケージ、たとえば @command{rcp}、@command{scp}、@command{rsync}
を使うものです。これらのメソッドは、ファイルのコピーコマンドがリモート
マシンのパスワードをたずねない場合にのみ有効です。

もし、リモートコピーメソッドが使えない場合のために、@value{tramp} は、
シェルを直接利用した符号化転送方法をサポートしています。この方法を使う
ためには、@command{mimencode} か @command{uuencode} がリモートマシン
上に存在しなければなりません。これらは一般に小さなファイルに対して速い
方法です。

上記の制限内であれば、@value{tramp} は非常にパワフルです。ただし、注意して
おかなければならないのは、現在の @value{tramp} は、エンドユーザー向けの洗練
された製品とはほど遠い状態であるということです。もうしばらくの間は、時々
ちょっと困った事になったり、コードに問題があるかもしれないということを
念頭においておいてください。

すでに開発者が日々の作業に使う事ができる程度には安定しています。しかし、
インストールと設定を覚えるのは、専門用語のせいで若干難しいでしょう。

@value{tramp} は、まだアクティブに開発をしている最中です。したがって、どんな
些細な問題であっても、ぜひ @value{tramp} 開発者に報告してください。
@xref{Bug Reports}.


@subsubheading 舞台の裏側
@cindex behind the scenes
@cindex details of operation
@cindex how it works

このセクションでは、@value{tramp} を使いリモートファイルにアクセスした時に、
舞台の裏側で何がおこっているかを説明します。

@kbd{C-x C-f} とタイプし、@value{tramp} のファイル名の一部を入力します。
それから、ファイル名の補完のために @kbd{@key{TAB}} を押します。これ
がそのホストに対する初めての @value{tramp} の起動の場合、以下のような事
がおこります。

@itemize
@item
@value{tramp} は、他のホストへの接続が必要な事を認識します。それから
@samp{telnet @var{host}} か @samp{rsh @var{host} -l @var{user}} あるい
は、その他のリモートホストへ接続するためのツールを起動します。これらの
プロセスとのコミュニケーションは @value{emacsname} のバッファを経由し
ておこなわれます。したがって、リモート側からの出力はこのバッファに出力
されます。

@item
リモートホストは、ログイン名のプロンプトを表示します(@command{telnet} 
の場合)。ログイン名は入力されたファイル名に含まれているので、@value{tramp} 
はログイン名と改行を送信します。

@item
リモートホストは、パスワードあるいはパスフレーズのプロンプトを表示
します(これは@command{rsh} の場合です。@command{telnet} の場合はログ
イン名を送信した後に表示されます)。@value{tramp} はミニバッファにプロン
プトを表示し、パスワードまたはパスフレーズをたずねます。

パスワードかパスフレーズを入力すると、@value{tramp} はそれをリモートホスト
に送信し、次に改行を送信します。

@item
@value{tramp} は、シェルプロンプトかログインに失敗した旨のメッセージを待ち
ます。

もし、@value{tramp} が、一定時間(たとえば一分)待っても、これらのメッセージを
発見することができなかったら、リモートシェルのプロンプトを発見できなかっ
た旨のメッセージを出力し、リモートホストから送信されたメッセージを表示
します。

もし、@value{tramp} が @samp{login failed} というメッセージを発見したら、それを
表示し、ログインを中止します。これで再びログインを試みることができます。

@item
ログインに成功し、@value{tramp} がシェルプロンプトを発見したとします。ここで、
@value{tramp} は @command{/bin/sh} を起動します。これは、Bourne シェルと C 
シェルでは文法が異なるためです。@footnote{ログインシェルが 
@samp{exec /bin/sh} を正しいコマンドとして認識せずに @command{/bin/sh}
の起動に失敗することがあるかもしれません。たぶん、あなたは Scheme シェル 
@command{scsh} を使っているのでしょう@dots{}}

Bourne シェルが起動されたら、@value{tramp} は確実に動作する環境を準備するため
にいくつかのコマンドを送信します。echo をオフにし、シェルプロンプトを設定
したり、その他いくつかの事をおこないます。

@item
さて、リモートシェルが起動されきちんと動作する状態になりました。ここで、
何がおこるはずだったか思いだしてください。リモートホスト上にどのような
ファイルが存在するかを @value{tramp} が調べ、ファイル名を補完できるようになる
ことです。

@value{tramp} は @command{cd} と @command{ls} コマンド、そして時々 globbing 
された @command{echo} を実行します。これ以外に、ファイルが書き込み可能
かどうか、ディレクトリかどうか等を調べるために @command{test} が、しば
しば使用されます。オペレーションをおこなうために、すべてのコマンドの出
力はパースされます。

@item
ファイル名の補完が完了し、@kbd{C-xC-f}と完全なファイル名を入力し、
@kbd{@key{RET}} を押したとしましょう。ファイルを編集するために、リモート
ホストからローカルホストにファイルの内容を転送する時がようやくやって
きました。

@value{tramp} がどのようにファイルの内容を転送するのかという説明は、上を見て
ください。

インライン転送のために、@value{tramp} は @samp{mimencode -b /path/to/remote/file}
のようなコマンドを実行し、出力がコミュニケーションのためのバッファに
蓄積されるまで待ちます。そして、ファイルの中身を作成するために、出力を
復号化します。

out-of-band 転送のために、@value{tramp} は以下のようなコマンドを実行します:
@example
rcp user@@host:/path/to/remote/file /tmp/tramp.4711
@end example
そして、ローカルな一時ファイル @file{/tmp/tramp.4711} をバッファに読み
込み、一時ファイルを削除します。

@item
今、あなたはバッファの内容を編集しています。しかし、幸運にも舞台裏で何が
おこっているのかに気がつきません(このセクションを読むまでは、そうでしょう)。
作業が終り、バッファを保存するために @kbd{C-x C-s} を押します。

@item
再び、@value{tramp} はファイルの内容をリモートホストにインラインか out-of-band
メソッドで転送します。ここではファイルを読み時におこっている事と逆のこと
がおこっています。

@end itemize

この説明で、@value{tramp} を使いファイルをオープンした時に舞台裏でおこっている
事をわかってもらえることを願っています。


@c For the end user
@node Obtaining Tramp
@chapter Tramp の入手方法
@cindex obtaining Tramp

@value{tramp} は、インターネット上でフリーに配布されています。最新版は
@uref{http://savannah.nongnu.org/download/tramp/}
からダウンロード可能です。この中には、インストールに必要な @value{tramp}
のすべてのドキュメントとソースコードが含まれています。しかし、Emacs
(21.4 かそれ以降のもの) は、@value{tramp} を含んでおり、XEmacs にも @value{tramp}
のパッケージがあります。したがって、それらを使う方がたぶん簡単でしょう。
しかし、もし最新の開発版を求めるのであれば、続きを読んで下さい@dots{...}

冒険家のために @value{tramp} は CVS からも入手可能です。CVS から入手した
バージョンはソースコードの最新バージョンです。したがって、不完全な
機能や新たな問題をかかえているかもしれません。このバージョンは自分
の責任で使用してください。

@value{tramp} の最新の開発バージョンを CVS から入手する方法は、以下に示す
Savannah プロジェクトページに行って一番上のナビゲーションバーにある
CVS のリンクをクリックすれば見ることが出来ます。

@noindent
@uref{http://savannah.gnu.org/projects/tramp/}

@noindent
もしくは、以下のセッションの例に従って下さい。

@example
] @strong{cd ~/@value{emacsdir}}
] @strong{cvs -d:pserver:anoncvs@@subversions.gnu.org:/cvsroot/tramp login}

CVS password: @strong{(just hit RET here)}
@dots{}

] @strong{cvs -z3 -d:pserver:anoncvs@@subversions.gnu.org:/cvsroot/tramp co tramp}
@end example

これで、@value{tramp} の最新バージョンが含まれるディレクトリ @file{~/@value{emacsdir}/tramp}
が作成されるはずです。以下のコマンドを実行することにより、最新のバージョン
に更新することができます:

@example
] @strong{cd ~/@value{emacsdir}/tramp}
] @strong{cvs update -d}
@end example

@noindent
CVS リポジトリからファイルを更新したら、新しい @file{configure} スクリプト
を生成するために @command{autoconf} を実行する必要があります:

@example
] @strong{cd ~/@value{emacsdir}/tramp}
] @strong{autoconf}
@end example


@node History
@chapter @value{tramp} の歴史
@cindex history
@cindex development history

@value{tramp} の開発は 1998 年の 11月下旬に始まりました。その当時は、この
パッケージは @file{rssh.el} と呼ばれていました。ファイルにアクセスするため
のたったひとつのメソッドがあるだけで、@command{ssh} を使用しリモート
ホストにログインし、@command{scp} でファイルの内容を転送していました。
しばらくして、名前が @file{rcp.el} に変わり、今は @value{tramp} と呼ばれています。
これに伴い、リモートシェルを起動しファイルの内容を転送する多くのメソッド
が追加されました。また、VC サポートも追加されました。

もっとも最近の大きな機能追加は、2000年4月のマルチホップメソッドの追加と、
2002年7月の @value{tramp} におけるファイル名と Ange-FTP におけるファイル名の
統一です。

@c Installation chapter is necessary only in case of standalone
@c installation.  Text taken from trampinst.texi.
@ifset installchapter
@include trampinst.texi
@end ifset

@node Configuration
@chapter @value{tramp} の設定
@cindex configuration

@cindex default configuration
@value{tramp} は(通常)インストールするだけで完全に機能します。初期状態では、
リモートホストへの接続に @command{ssh} プログラムを使用し、base64 エン
コーディングもしくは uu エンコーディングを使用するように設定されていま
す。 従って最も簡単な場合には @kbd{C-x C-f} と打ち込んでファイル名
@file{@value{prefix}@var{user}@@@var{machine}@value{postfix}@var{/path/to.file}}.
を入力するだけです。

ホストによっては、接続を確立するのに問題が起きることがあります。これは、
 remote shell の振る舞いによるものです。この詳細については @xref{Remote
shell setup}, を参照してください。

もし、リモートホストとの接続にこれらのコマンドを使用したくない場合は、
@value{tramp} のデフォルトの接続と転送メソッドを変更してください。リモート
マシンに接続しファイルを転送するのに使うことのできる @value{tramp} のメソッド
がいくつかあります (@pxref{Connection types})。

どのメソッドがふさわしいかわからないなら次を見て下さい: @xref{Default Method}.


@menu
* Connection types::            リモートマシンへの接続の種類
* Inline methods::              インラインメソッド
* External transfer methods::   外部転送メソッド
* Multi-hop Methods::           マルチホップを使用したリモートホストへの接続
* Default Method::              デフォルトのメソッドの選択
                                  ここではどのメソッドを使えばよいか
                                  わからない人のお手伝いもします。
* Customizing Methods::         非標準のメソッドを使う
* Customizing Completion::      ユーザ/ホスト名補完のための設定ファイルの選択
* Remote Programs::             リモートマシン上で @value{tramp} がプログラムを発見、使用する方法
* Remote shell setup::          リモートシェル設定のヒント
* Windows setup hints::         Cygwin ssh にまつわる事柄
* Auto-save and Backup::        Auto-save とバックアップ
@end menu


@node Connection types
@section リモートマシンへの接続の種類
@cindex connection types, overview

転送メソッドには二つの基本的なタイプがあり、それぞれに長所、短所が
あります。両者ともに、@command{rsh} や @command{ssh}、@command{telnet} 
のようなリモートシェルにアクセスするプログラムを使用し、リモートマシン
に接続します。

このコネクションは、@value{tramp} がローカルマシンからリモートマシンへ透過的
にアクセスするために、さまざまなオペレーションをおこなうために使われます。
ファイルをオープンした時のメソッドが異なるだけです。

@cindex inline methods
@cindex external transfer methods
@cindex external methods
@cindex out-of-band methods
@cindex methods, inline
@cindex methods, external transfer
@cindex methods, out-of-band
リモートファイルを読み込んだり、保存する時には、二つのマシン間でファイル
の内容を転送する必要があります。ファイルの内容は、マシンにログインしたの
と同じコネクションか、@command{rcp} や @command{scp}、@command{rsync}
などのリモートコピープログラムを使用した別のコネクションで転送されます。
前者は @dfn{インラインメソッド}、後者は @dfn{out-of-band メソッド} あるいは
@dfn{外部転送メソッド} (略して @dfn{外部メソッド}) とよばれます。

少なくとも大きなファイルに対しては、一般に外部転送メソッドの性能は
インラインメソッドよりすぐれています。その理由は、インライン転送では
データの符号化、復号化をおこなう必要があるからです。

このルールの唯一の例外は、@command{scp} を使用する転送メソッドです。
これらのメソッドの実際のファイル転送の性能は高いのですが、転送開始時
の暗号化にかかわるネゴシエーションのオーバーヘッドがファイル転送の性能
を帳消しにします。

外部転送メソッドを使うためには、リモートコピーコマンドが対話的でない、
つまりコマンドがパスワードのためにプロンプトを出力しないことが必要です。
もし、パスワード入力なしのリモートコピーコマンドを使う事ができないので
あれば、インラインメソッドを使う必要があります。

@cindex multi-hop methods
@cindex methods, multi-hop
インラインメソッドの一種に、@dfn{マルチホップメソッド} があります。
このメソッドを使うと、いくつかのホップを使い、リモートホストへ接続
できます。これは、あなたがセキュアなネットワークの中にいて、要塞ホスト
を経由して外部に接続する場合に便利です。


@node Inline methods
@section インラインメソッド
@cindex inline methods
@cindex methods, inline

@value{tramp} のインラインメソッドは大変強力で、外部転送メソッドを使う事が
できない状況でも動作します。インラインメソッドは、telnet 経由でリモート
マシンに接続している時に動作する唯一のメソッドです(ホスト間でなく 
@emph{ユーザー} 間のファイル転送を可能にする、ちょっと変わったメソッド
もあります。以下を参照してください)。

これらのメソッドを使うためには、符号化、復号化のためのコマンドがリモート
マシン上に存在しなければなりません。ローカルマシン上では、@value{tramp} は
ファイルを復号化、符号化する Emacs の機能を使うか、外部コマンドを使用
します。

@cindex uuencode
@cindex mimencode
@cindex base-64 encoding
@value{tramp} は、リモートホストにおいて @command{mimencode}
(@command{metamail} パッケージの一部) や @command{uuencode} といった
コマンドの存在と、それが使えるかどうかを調べます。最初の信頼できるコマンドが
使われます。検索パスをカスタマイズすることができます。@ref{Remote
Programs} を参照して下さい。

もしどちらのコマンドもリモートホストに無かった場合、 @value{tramp} は小さな
Perl のコードをリモートホストに転送し、それをエンコードやデコードに用い
ようとします。


@table @asis
@item @option{rsh}
@cindex method rsh
@cindex rsh method

リモートホストに @command{rsh} で接続します。セキュアでない接続の為、
極めてローカルなホストトポロジー以外に用いるべきではありません。

@command{rsh} の代わりに @command{remsh} コマンドを提供するオペレーテ
ィングシステムではメソッド @option{remsh} を使うこともできます。例えば
HP-UX や Cray UNICOS の場合があてはまります。


@item @option{ssh}
@cindex method ssh
@cindex ssh method

リモートホストに @command{ssh} で接続します。@command{ssh} パッケージ
を用いて接続をよりセキュアにしていることを除けば先ほどのオプションと同
じです。

@option{ssh1} と @option{ssh2} という二つの変種があり、それぞれは
@samp{ssh -1} と @samp{ssh -2} を呼び出します。このようにして、
SSH プロトコルバージョン 1 と 2 のどちらを用いてリモートホストに接続
するかを明示的に選択することができます。(SSH の設定ファイル @file{~/.ssh/config}
でどちらのプロトコルを用いるか指定し、通常の @option{ssh} メソッドを用いる
こともできます。)

またそのほかに、 @option{ssh1_old} と @option{ssh2_old} という二つの変種が
存在し、明示的に @command{ssh1} コマンドと @command{ssh2} コマンドを使います。
それらが何か知らないなら、これらのオプションはあなたには必要ありません。

@command{ssh} に基づく全てのメソッドは、クルージ的特徴を持ちます:
@file{host#42} のようにして(実ホスト名に続けてハッシュ記号、そしてポート番号)
ホスト名を指定することができます。これの意味は、指定したホストに接続する際に、
@command{ssh} コマンドの引数として @code{-p 42} を渡すということです。


@item @option{telnet}
@cindex method telnet
@cindex telnet method

リモートホストに @command{telnet} で接続します。これは @option{rsh} メソッド
と同様にセキュアでない方法です。


@item @option{su}
@cindex method su
@cindex su method

このメソッドはリモートホストに接続しません。そのかわりに @command{su}
プログラムを使うことで他のユーザとしてファイルを編集することを可能と
します。


@item @option{sudo}
@cindex method sudo
@cindex sudo method

このメソッドは、@option{su} メソッドに似ていますが、違うユーザーになる
ために @command{su} でなく @command{sudo} を使用します。

そのユーザーでシェルを起動できるように、@command{sudo} が設定されていな
ければならないことに注意してください。@command{ls} と @command{mimedecode} 
の起動の許可だけで十分であればよいのですが、そのように実装するのは簡単では
なく、まだ無理です。


@item @option{sshx}
@cindex method sshx
@cindex sshx method
@cindex Cygwin (with sshx method)

お分かりのように、これは @option{ssh} とちょっと違った類似物です。
@option{ssh} がリモートホストで通常の対話的シェルを開くのに対し、
このオプションは @samp{ssh -t -t @var{host} -l @var{user} /bin/sh}
を使って接続を行ないます。この方法は、通常のログインシェルが、ログイン
の際に質問をしてくるように設定してある場合に有用です。この手順により
それらの質問を回避して、`標準的な' ログインシェルを @value{tramp} に使わせ
ることができます。

この手続きは @command{ssh} 自身からの質問を排除しないことに注意して下
さい。例えばリモートホストのホスト鍵が未知の物である場合に、``Are you
sure you want to continue connecting?'' と @command{ssh} が訊いてくる
かもしれません。@value{tramp}  は(今のところ)そのような質問を扱う方法を知ら
ないので、そのような質問をされないでログインできるようにしておく必要が
あります。

この手順は、 @command{ssh} を Emacs バッファから呼ぶと pseudo tty を割
り当ててないと言われてしまう Windows ユーザにとっても有用です。この時、
ログインシェルはシェルプロンプトを一切表示しようとしなくて、それは
@value{tramp} を大変混乱させてしまいます。未知の理由により、いくつかの
@command{ssh} の Windows への移植版(たぶん Cygwin のものも)は  @samp{-t}
オプションを二つ重ねて使うことを要求します。

これは @samp{-p} クルージをサポートします。


@item @option{krlogin}
@cindex method krlogin
@cindex km krlogin
@cindex Kerberos (with krlogin method)

このメソッドも @option{ssh} に似ています。リモートホストにログインするのに
@command{krlogin -x} コマンドを使うだけです。


@item @option{plink}
@cindex method plink
@cindex plink method

このメソッドは SSH の PuTTY 実装を使っている Windows ユーザにとって
とても興味深いものです。リモートホストにログインするのに @samp{plink -ssh}
を使います。

さらにメソッド @option{plink1} が提供されます。それは
明示的に SSH プロトコルバージョン 1 を使うために
@samp{plink -1 -ssh} を呼び出します。

CCC: SSH key を受理するためにコマンドラインからリモートホストへ繋ぐ必要は
あるのか? これは自動化できないか?

CCC: @command{plink} は @samp{-p} オプションをサポートしているか? いずれに
せよ @value{tramp} はそれをサポートする。

@end table



@node External transfer methods
@section 外部転送メソッド
@cindex methods, external transfer
@cindex methods, out-of-band
@cindex external transfer methods
@cindex out-of-band methods


外部転送メソッドは複数のチャネルを使用します。オペレーションのために
リモートシェルのコネクションを使い、ファイル転送には、外部プログラム
を使います。

これは、インライン転送時の、ひとつのコネクションを使った多重化転送のため
の符号化、復号化のオーバーヘッドを削減します。

外部転送メソッドを使いたい場合は、ファイルをコピーするための転送ユーティ
リティが、パスワード入力なしで実行できなければなりません。

@cindex ssh-agent
つまり、@command{scp} を使う場合や、使っている @command{scp} がコマンド
ラインでパスワードを受け付けるバージョンの場合には、@command{ssh-agent}
を使う必要があるということです。@footnote{PuTTY's @command{pscp} では
コマンドラインでパスワードを指定できます。}
@command{ssh} 経由で @command{rsync} を使う場合も同様です。

もし、パスワード入力なしで @command{scp} を実行することができないが、
コネクションをセキュアにするために @command{ssh} を使いたい場合は、
@command{ssh} ベースのインラインメソッドを参照してください。


@table @asis
@item @option{rcp}  ---  @command{rsh} と @command{rcp}
@cindex method rcp
@cindex rcp method
@cindex rcp (with rcp method)
@cindex rsh (with rcp method)

このメソッドは @command{rsh} と @command{rcp} を使い、リモートマシン
に接続、ファイル転送をおこないます。おそらく最速のメソッドです。

もう一つ別のメソッド @option{remcp} では @command{remsh} コマンドと
@command{rcp} コマンドを使います。これは @command{rsh} の代わりに
@command{remsh} が使われるマシン上で使われるべきです。


@item @option{scp}  ---  @command{ssh} と @command{scp}
@cindex method scp
@cindex scp method
@cindex scp (with scp method)
@cindex ssh (with scp method)

リモートホストへの接続のための @command{ssh} や、マシン間のファイル転送
のための @command{scp} は、リモートマシンへのセキュアな接続とファイル
アクセスのためには最良のメソッドです。

このオプションの性能も優れています。しかし、小さいファイルのオープン、
クローズを頻繁に繰り返す場合はインラインメソッドより遅くなります。
@command{scp}セッション開始時の暗号化のためのハンドシェークのコストは、
符号化、復号化をおこなわない利点を帳消しにします。

@option{scp1} と @option{scp2} という二つの変種があり、それぞれは
@samp{ssh -1} と @samp{ssh -2} を呼び出します。このようにして、
SSH プロトコルバージョン 1 と 2 のどちらを用いてリモートホストに接続
するかを明示的に選択することができます。(SSH の設定ファイル @file{~/.ssh/config}
でどちらのプロトコルを用いるか指定し、通常の @option{scp} メソッドを用いる
こともできます。)

またそのほかに、 @option{scp1_old} と @option{scp2_old} という二つの変種が
存在し、明示的に @command{ssh1} コマンドと @command{ssh2} コマンドを使います。
それらが何か知らないなら、これらのオプションはあなたには必要ありません。

@command{ssh} に基づく全てのメソッドは、 @samp{-p} に関するクルージ的
特徴を持っており、ホスト名の中でポート番号を指定できます。例えばホスト
名を @file{host#42} とすることで @command{ssh} コマンドの引数リストに
@code{-p 42} を指定するように @value{tramp} に指示できます。


@item @option{rsync}  ---  @command{ssh} と @command{rsync}
@cindex method rsync
@cindex rsync method
@cindex rsync (with rsync method)
@cindex ssh (with rsync method)

リモートホストにセキュアに接続するために @command{ssh} コマンドを、
ファイル転送のために @command{rsync} を使うのが、@option{scp}
メソッドの特徴です。

両側のホスト上に存在するファイルを転送する場合、@command{rsync} は
@command{scp} より高性能です。この利点は、ファイルが片側のホストに
しかない場合には失なわれます。

リモートシステムへ書き込む場合、@command{rsync} ベースのメソッドは
@command{rcp} ベースのメソッドよりかなり速いでしょう。しかし、ローカル
マシンのファイルを読み込む場合は、直接コピーするより速くありません。

このメソッドは @samp{-p} ハックをサポートします。


@item @option{scpx} --- @command{ssh} と @command{scp}
@cindex method scpx
@cindex scpx method
@cindex scp (with scpx method)
@cindex ssh (with scpx method)
@cindex Cygwin (with scpx method)

想像通り、このメソッドは @option{scp} とよく似ています。@option{scp} が
リモートホスト上で通常の対話的シェルを起動するのに対して、このオプション
はコネクションをオープンするために @samp{ssh -t -t @var{host} -l
@var{user} /bin/sh}
を使います。このオプションは、通常のログインシェルがログイン時にいくつか
の質問をおこなうように設定されている場合に役に立ちます。この手順により
それらの質問を回避して、`標準的な' ログインシェルを @value{tramp} に使わせ
ることができます。

この手順は Windows ユーザにとって @command{ssh} を Emacs バッファから
呼ぶと pseudo tty を割り当ててないと言われてしまう場合にも有用です。
この時ログインシェルはシェルプロンプトを一切表示しないために @value{tramp}
は大変混乱してしまいます。たぶんこれは Cygwin に移植されたSSH の場合に
当てはまります。

このメソッドは @samp{-p} ハックをサポートします。


@item @option{pscp} --- @command{plink} と @command{pscp}
@cindex method pscp
@cindex pscp method
@cindex pscp (with pscp method)
@cindex plink (with pscp method)
@cindex PuTTY (with pscp method)

このメソッドは @option{scp} に似ていますが、リモートホストに接続するの
に @command{plink} コマンドを使い、ファイルを転送するのに @command{pscp}
を使います。これらのコマンドは Windows 用の SSH 実装である PuTTY に
含まれています。

CCC: @command{plink} は @samp{-p} ハックをサポートしているか?


@item @option{fcp} --- @command{fsh} と @command{fcp}
@cindex method fcp
@cindex fcp method
@cindex fsh (with fcp method)
@cindex fcp (with fcp method)

このメソッドは @option{scp} に似ていますが、リモートホストに接続するの
に @command{fsh} コマンドを使い、ファイルを転送するのに @command{fcp}
を使います。 @command{fsh/fcp} は @command{ssh} のフロントエンドで、
同一の @command{ssh} セッションを再利用していくつかのコマンドを送るこ
とを可能とします。これにより、@command{scp} の起動にかかるオーバーヘッド
(呼ばれる度にセキュアな接続を確立しないといけない)を回避できます。
一方、同様の効果を得るためにインラインメソッドのどれかを用いることも
できることを注意しておきます。

このメソッドはコマンド @samp{fsh @var{host} -l @var{user} /bin/sh -i}
を使って接続を確立します。単に @command{fsh @var{host} -l @var{user}}
としただけでは動きません。

@cindex method fsh
@cindex fsh method
@command{fsh} プログラムが提供する多重化は我々の文脈ではそれほど有用で
はないので、それを用いるインラインメソッドは存在しません。その代わり
@value{tramp} は単にリモートホストへの一つの接続を開き、その接続を保持します。


@ifset emacs
@item @option{ftp}
@cindex method ftp
@cindex ftp method

これは @value{tramp} 独自のメソッドではありません。その代わりに全ての要求を
@value{ftppackagename} に転送します。
@end ifset


@item @option{smb} --- @command{smbclient}
@cindex method smb
@cindex smb method

これはまた別の @value{tramp} 独自でないメソッドです。@command{smbclient} 
コマンドを別の Unices 上で使って、SMB サーバへの接続を行ないます。
SMB サーバは別の UNIX ホスト上の Samba (もしくは CIFS) サーバであるか
もしれませんし、さらに興味深いことに、MS Windows が動いているホストで
あるかもしれないのです。今のところ、MS Windows NT、MS Windows 2000、
および MS Windows XP に対してテストされています。

ローカル名の先頭のディレクトリはリモートホストでの共有名でなければなり
ません。通常デフォルトの共有の終端は文字 @code{$} ですが、ファイル名の
環境変数による展開のため、それを @code{$$} と書く必要があることを憶えて
おいて下さい。もし、共有名が与えられなければ(すなわちリモートディレクトリ
が @code{/} の場合)、全ての利用可能な共有たちが表示されます。

認可は共有レベルでなされているので、同じホストであっても別の共有にアク
セスすると必ずパスワードを求められます。セキュリティ上の理由からパスワ
ードはキャッシュされません。

MS Windows は認可のためにユーザ名とドメイン名の両方を用います。このた
め、@value{tramp} 構文は拡張されました: ユーザ名を指定する際に @code{user%domain}
(実ユーザ名、パーセント記号、ドメイン名)のように書くことができます。
したがって、マシン @code{melancholia} にドメイン @code{BIZARRE} のユーザ
@code{daniel} として接続して、ホームディレクトリ (共有 @code{daniel$})
にある @file{.emacs} を編集する場合、ファイル名を
@file{@value{prefix}smb@value{postfixsinglehop}daniel%BIZARRE@@melancholia@value{postfix}/daniel$$/.emacs}
と指定します。

ドメイン名やユーザ名は付けないこともできます。もしユーザ名が指定されな
ければ匿名ユーザ(パスワード入力の必要がない)が仮定されます。これは他の
全ての @value{tramp} メソッドと異なります。他のメソッドで同じ状況の場合には
ローカルユーザ名が使われます。

@option{smb} メソッドは @samp{-p} ハックをサポートします。

@strong{注意して下さい:} もし Emacs がローカルの MS Windows の下で動い
ているならばこのメソッドは利用できません。その代わりに、
@file{//melancholia/daniel$$/.emacs} のような UNC ファイル名を使うこと
ができます。唯一の欠点は他のユーザ名を指定するための方法が無いことです。

@end table

@node Multi-hop Methods
@section 複数のホップを使いリモートホストに接続する
@cindex multi-hop methods
@cindex methods, multi-hop

これまでに説明したメソッドでは不十分な事があります。シンプルなメソッドを
使ってリモートホストに接続できないことがあります。たとえば、セキュアな
ネットワークの中にいる場合、外部に接続する前にまず要塞ホストにログイン
しなければならないでしょう。もちろん、ターゲットホストは要塞ホストも要求
します。マルチホップのファイル名のフォーマットは、通常の @value{tramp} の
メソッドとすこし異なります。

@cindex method multi
@cindex multi method
マルチホップのファイル名は、メソッド名、ホップ数、ローカル名(リモート
システム上のパス名)を指定します。メソッド名は常に @option{multi} です。

各ホップは @dfn{ホップメソッド} 指定、つまりユーザ名とホスト名から成り
ます。ホップメソッドはインラインメソッドのみになり得ます。以下のホップ
メソッドが(今のところ)利用可能です:

@table @option
@item telnet
@cindex hop method telnet
@cindex telnet hop method

ホストへの接続によく知られた @command{telnet} プログラムを使用します。
ユーザー名とホスト名はファイル名の中に含まれ、パスワードをたずねられます。

@item rsh
@cindex hop method rsh
@cindex rsh hop method

ホストへの接続に @command{rsh} を使用します。@command{rsh} がパスワード
をたずねる時以外は、パスワードを入力する必要はありません。

この変種 @option{remsh} は @command{remsh} コマンドを使います。これは
@command{rsh} の代わりに @command{remsh} が使われるマシン上で使われる
べきです。

@item ssh
@cindex hop method ssh
@cindex ssh hop method

このメソッドはホストへの接続のために @command{ssh} を使用します。パスワード
かパスフレーズを入力する必要があります。

@item su
@cindex hop method su
@cindex su hop method

このメソッドは他のホストへまったくアクセスしません。そのかわり、今いる
ホスト上で他のユーザーになることができます。これは、root としてファイル
を編集したいが、リモートホストはリモートからの root のログインを許可して
いない場合に役に立ちます。このような場合、一般ユーザーでのリモートホスト
への接続に @option{telnet}、@option{rsh} あるいは @option{ssh} を使う
ことができます。それから、root になるために @option{su} ホップを使います。
@option{su} は一連のシークエンス中の最後のホップである必要はありません。
必要であればホップ中のどこででも使うことができます。

@option{su} ホップと一緒にユーザーとホスト両方を指定しなければなりません。
しかしながら、ホスト名は無視されユーザー名だけが使用されます。

@item sudo
@cindex hop method sudo
@cindex sudo hop method

これは @option{su} ホップに似ています。違うユーザーになるために
@command{su} でなく @command{sudo} を使用する点が異なります。

@end table

@command{ssh} を用いてポートフォワードをしたい場合や、標準的でないポートを
使用しなければならない場合があるかもしれません。そのような場合には、
ホスト名ごとに異なるポート番号を指定した記述を @file{~/.ssh/config} に
書き込むことで実現できます。しかしながら、マルチホップメソッドを使えば
それは @value{tramp} の枠内で実現することもできます。例えば:

@lisp
(add-to-list
 'tramp-multi-connection-function-alist
 '("sshf" tramp-multi-connect-rlogin "ssh %h -l %u -p 4400%n"))
@end lisp

とすれば、 @code{sshf} ホップを用いて、標準的なポートの変わりに 4400 番
ポートへ繋ぐことができます。


@node Default Method
@section デフォルトのメソッドの選択
@cindex default method

@vindex tramp-default-method
普段よく使う適切な転送メソッドを選択するには、変数 @code{tramp-default-method}
を設定しなければなりません。この変数には @value{tramp} ファイル名にメソッドが
指定されなかった時に使用されるデフォルトのメソッドを設定します。
例えば:

@lisp
(setq tramp-default-method "scp")
@end lisp

@vindex tramp-default-method-alist
変数 @code{tramp-default-method-alist} を使って特定のユーザ/ホストの
組み合わせに対して異なったメソッドを指定することができます。例えば
次の2行は、ユーザ名が @samp{john} にマッチする場合には @option{ssh}
メソッドを用い、ホスト名が @samp{lily} にマッチする場合には @option{rsync}
メソッドを用います。3行目はマシン @samp{localhost} 上のユーザ@samp{root}
に対して @option{su} メソッドを使うように指定します。

@lisp
(add-to-list 'tramp-default-method-alist '("" "john" "ssh"))
(add-to-list 'tramp-default-method-alist '("lily" "" "rsync"))
(add-to-list 'tramp-default-method-alist
             '("\\`localhost\\'" "\\`root\\'" "su"))
@end lisp

@noindent
さらなる詳細については変数 @code{tramp-default-method-alist} のドキュメント
を見て下さい。

一般的には、インライン転送メソッドよりは外部転送メソッドを選ぶべきです。
外部転送メソッドはインラインより高性能です。しかし、外部転送メソッドは、
パスワード入力なしでログインできないリモートマシンがたくさんある場合は
役に立ちません。

@xref{Inline methods}.
@xref{External transfer methods}.
@xref{Multi-hop Methods}.

転送メソッドの選択をする時に他に考慮すべき事は、それらを使う環境と、
特にインターネット上で使う場合あなたの選択したメソッドのセキュリティ
との関係です。

@command{rsh} と @command{telnet} メソッドは、リモートマシンにログイン
する時に、パスワードをプレインテキストで送信します。ファイル転送も同じ
方法でおこなうので、他もマシンからファイルの内容を簡単に読むことができます。

インターネットからアクセス可能なリモートシステムに接続する必要がある場合、
接続に @command{ssh} ベースのメソッドを使用することを真剣に考えるべきです。
このメソッドは、高いレベルのセキュリティを提供し、誰かがパスワードを入手
したり、編集しているファイルの内容を読んだりすることを困難にします。


@subsection 私はどのメソッドを使うべきか?
@cindex choosing the right method

ここまでの説明で、これは全くすばらしくて良いものだが、しかしながらメソッド
を選ぶ方法については何の助言もされてないよ! と思うことと思います。確かに。
開発者としては、ユーザを牛耳ろうとは思ってなくて、代わりに最大限の自由度を
与えようと考えています。しかしながら実際にはユーザの中には手引きを求める
人も居るでしょう。そこでここではあなたを支配することなく手引きを与えること
を試みます。これがうまく行ったか教えて下さいね @dots{}

私の提案は、インラインメソッドを使うことです。大きなファイルに対しては
out-of-band メソッドの方が有効かもしれませんが、ほとんどの人は小さな
ファイルを編集したいと思うと推測します。

今日では、ほとんどの人がリモートマシンに @code{ssh} を使ってアクセス
できると推測します。したがって @code{ssh} メソッドを使うことを提案します。
つまり、他のホストの @file{/etc/motd} ファイルを編集するためには
@kbd{C-x C-f /ssh:root@@otherhost:/etc/motd @key{RET}} と入力すればよい
です。

もし、@code{ssh} を使ってリモートホストにログインできないなら、動作する
プログラムを使うメソッドを選択します。例えば Windows ユーザは @code{ssh}
の PuTTY 実装を使う @code{plink} メソッドを好むかもしれません。また、
Kerberos を使っているなら @code{krlogin} を好むでしょう。

特別な場合としてローカルホストのファイルを別のユーザとして編集したい場合
には @code{su} メソッドもしくは @code{sudo} メソッドを参照して下さい。

大きなファイルを編集する人は @code{ssh} の代わりに @code{scp} 、もしくは
@code{plink} の代わりに @code{pscp} の利用を考えるかもしれません。
これらの out-of-band メソッドは大きなファイルに対してはインラインメソッド
よりも高速です。しかし、out-of-band メソッドたちはいくつかの制限
を受けるかもしれないことに注意して下さい。最初に本当に顕著な速度的な
優位を out-of-band メソッドで得られるか試して下さい!おそらく大きなファイル
に対してもインラインメソッドたちは十分高速だと思います。

私がインラインメソッドの利用を提案する理由は、それらはリモート側が
パスワードを聞いてきたとしても動作するからです。out-of-band メソッド
はそのような状況では動作しません。また、マルチホップメソッドたちは
本質的にインラインです。


@node Customizing Methods
@section 非標準のメソッドを使う
@cindex customizing methods
@cindex using non-standard methods
@cindex create your own methods

事前に定義されたメソッドだけでは不十分な場合に、それを変更するための 
@code{tramp-methods} という変数があります。

変更が必要になった時のために、この変数の Lisp ドキュメントについて述べて
おきます。ドキュメントは @kbd{C-h v tramp-methods @key{RET}} で参照する
ことができます。


@node Customizing Completion
@section ユーザ/ホスト名補完のための設定ファイルの選択
@cindex customizing completion
@cindex selecting config files
@vindex tramp-completion-function-alist

変数 @code{tramp-completion-function-alist} は、ユーザ名とホスト名の
補完 (@pxref{Filename completion}) の際にどのファイルたちを考慮に入れ
るかをカスタマイズするためにあります。この変数は各々のメソッドに対して、
設定ファイルの集合とそのファイルをパースできる Lisp 関数との組を保持し
ます。@code{tramp-completion-function-alist} のエントリは
(@var{method} @var{pair1} @var{pair2} ...) の形式をとります。

それぞれの @var{pair} は (@var{function} @var{file}) から成ります。
@var{function} は補完の際に @var{file} からユーザ名とホスト名を取り出
すのに使われます。この変数にアクセスする二つの関数があります:

@defun tramp-get-completion-function method
この関数は @var{method} に対する補完関数のリストを返します。

Example:
@example
(tramp-get-completion-function "rsh")

     @result{} ((tramp-parse-rhosts "/etc/hosts.equiv")
         (tramp-parse-rhosts "~/.rhosts"))
@end example
@end defun

@defun tramp-set-completion-function method function-list
この関数は @var{method} に対する補完関数のリストを @var{function-list}
に設定します。

Example:
@example
(tramp-set-completion-function "ssh"
 '((tramp-parse-sconfig "/etc/ssh_config")
   (tramp-parse-sconfig "~/.ssh/config")))

     @result{} ((tramp-parse-sconfig "/etc/ssh_config")
         (tramp-parse-sconfig "~/.ssh/config"))
@end example
@end defun

設定ファイルをパースするための以下の関数があらかじめ定義されています:

@table @asis
@item @code{tramp-parse-rhosts}
@findex tramp-parse-rhosts

この関数は構文的に @file{~/.rhosts} と等価なファイルをパースします。もし
書かれていればホスト名とユーザ名の両方を返します。

@item @code{tramp-parse-shosts}
@findex tramp-parse-shosts

この関数は構文的に @file{~/.ssh/known_hosts} と等価なファイルをパースします。
そのファイルにはユーザ名は書かれていないのでホスト名のみを返します。

@item @code{tramp-parse-sconfig}
@findex tramp-parse-shosts

この関数は @file{~/.ssh/config} 形式のファイルの @code{Host} エントリで
定義されたホストのあだなを返します。

@item @code{tramp-parse-hosts}
@findex tramp-parse-hosts

@file{/etc/hosts} 形式のファイルのための関数です。ホスト名のみを返します。

@item @code{tramp-parse-passwd}
@findex tramp-parse-passwd

@file{/etc/passwd} のようなファイルをパースする関数です。当然ながらユーザ
名のみを返します。

@item @code{tramp-parse-netrc}
@findex tramp-parse-netrc

最後に、これは @file{~/.netrc} のようなファイルをパースする関数です。
@end table

もし独自のデータを独自の構造でファイルに保持したいなら、このような関数
を提供すればよいです。この関数は以下の慣習に合致する必要があります。

@defun my-tramp-parse file
@var{file} はあなたのホストにあるファイル名もしくは @code{nil} のいずれか
です。この関数は (@var{user} @var{host}) のリストを返さねばなりません。
それらはユーザ/ホスト名補完の候補として使われます。

Example:
@example
(my-tramp-parse "~/.my-tramp-hosts")

     @result{} ((nil "toto") ("daniel" "melancholia"))
@end example
@end defun


@node Remote Programs
@section リモートマシン上で @value{tramp} がプログラムを発見、使用する方法

@value{tramp} はリモートホスト上のいくつかのプログラム、@command{ls}、
@command{test}、@command{find} そして @command{cat} に依存しています。

これらのツールにくわえ、コネクションメソッドのためにいくつかのツールが
必要です。詳細は @ref{Inline methods} と @ref{External transfer methods} 
を参照してください。

いくつかの他のツール、@command{perl} (あるいは @command{perl5}) と
@command{grep} が存在すればそれらも使用されます。これは、性能と
リモートファイルアクセスの正確さの向上のためです。

@vindex tramp-remote-path
@value{tramp} はリモートマシンに接続した時に、使用可能プログラムを検索します。
変数 @var{tramp-remote-path} は、リモートマシン上で検索されるディレクトリ
を制御します。

デフォルトで多くのマシンにとって適切なパスが設定されています。しかし
ながら、ローカル(あるいはリモート)システムの管理者が、必要なツールを
へんぴなディレクトリにインストールしているかもしれません。

このような場合でも @value{tramp} を使う事ができます。単に、必要なディレクトリ
をリモートパスに追加するコードを @file{.emacs} に書くだけです。これで
接続時に @value{tramp} により、追加したディレクトリが検索されプログラムが
発見されます。

リモートサーチパスにディレクトリを追加するためには、以下のような
コードを使ってください:

@lisp
@i{;; 変数を定義するために @value{tramp} をロードする}
(require 'tramp)
@i{;; @command{perl} が "/usr/local/perl/bin" にある}
(add-to-list 'tramp-remote-path "/usr/local/perl/bin")
@end lisp

@node Remote shell setup
@comment  node-name,  next,  previous,  up
@section リモートシェルの設定のヒント
@cindex remote shell setup
@cindex @file{.profile} file
@cindex @file{.login} file
@cindex shell init files

@ref{Overview} の節で説明したように、@value{tramp} はリモートホストに接続し、
そこにあるシェルと対話します。もちろんログインする際にはシェルはその
初期化ファイルを実行します。例えばあなたの初期化ファイルがあなたのお母
さんの誕生日を入力させるようになっていたとしましょう; 当然 @value{tramp}
はそのことを知らないので、そのホストへのログインに失敗します。

この問題を追求するために、いくつかの戦略が考えられます。一つは、@value{tramp}
がすべての可能な状況に対応できるようにすることです。これは消耗戦です。
何故なら @emph{全ての} 状況を扱うことは不可能だからです。別の手として、
@value{tramp} の期待通りに振る舞うように、あなたにリモートホストの設定をして
いただくということも出来ます。しかしこれは不便かもしれません。何故なら
@value{tramp} を使い始めるより先に、シェルの設定に多くの労力を割く必要がある
のですから。

そのことから、このパッケージではそれらを組み合わせた方法をとります。
いくつかのありふれた設定については理解しようとしてくれて、あなたには
本当に特異な設定だけを避けるように求めます。例えば、リモートホスト上で
あるプログラムを見つけるためには、ディレクトリの一覧を調べます。
そしてまた、ファイルが存在するかをどうか調べる方法というのも明らかでは
ないので、いくつかの異なる可能性を試してくれます。
(あるホストとシェルにおいては、@code{test -e} コマンドがその役目を果たす。
別のホスト、シェルに対してはシェルの組み込みコマンドは働かないが、
@code{/usr/bin/test -e} や @code{/bin/test -e} ならうまく働く。
そしてさらに別のホストでは @code{ls -d} がその方法として働く。)

以下では、@value{tramp} が取り扱ってくれない、つまりあなたが正しく設定する必要
のあるいくつかの事柄について述べます。

@table @asis
@item @var{shell-prompt-pattern}
@vindex shell-prompt-pattern

リモートホストにログインした後、@value{tramp} がリモートシェルに命令を送れる
ようになる前に、リモートシェルのセットアップが終了するのを待つ必要があり
ます。シェルプロンプトを認識する為に、変数 @code{shell-prompt-pattern}
をリモートホストのシェルプロンプトを認識出来るように設定しておく必要が
あります。

@value{tramp} は @code{shell-prompt-pattern} に対してバッファ末尾でマッチす
ることを要求することに注意して下さい。多くの人はこの変数の値として次の
ようなものを指定しています: @code{"^[^>$][>$] *"}。ここであなたのシェル
プロンプトが @code{a <b> c $ } のようなものだったとしましょう。この場合、
@value{tramp} は文字@code{>} をプロンプトの終端と認識しますが、それはバッファ
の終端にはありません。

@item @var{tramp-shell-prompt-pattern}
@vindex tramp-shell-prompt-pattern

この正規表現は @code{shell-prompt-pattern} と同様にリモートシェルの
プロンプトにマッチするものとして使われます。この二つ目の変数はリモート
シェルのプロンプトがローカルシェルと異なる可能性があるので存在します。
とにかく @value{tramp} の要点はリモートホストに別のユーザとしてログインする
ことです。@code{tramp-shell-prompt-pattern} のデフォルトの値は
@code{shell-prompt-pattern} のデフォルト値と同一のものですが、多くの状況
でそれはうまく働くと報告されています。

@item @code{tset} とその他の質問
@cindex Unix command tset
@cindex tset Unix command

シェルの起動スクリプトから @code{tset} プログラムを呼び出し、
シェルの端末の種類を尋ねるようにしている場合があります。たぶん
シェルによってはその他の質問を起動時にしてくる場合もあるでしょう。
@value{tramp} はこれらの質問に答える方法を知りません。この問題を扱うには
二つのアプローチがあります。一つのアプローチは、シェルが @value{tramp} から
呼び出されたときに何の質問もしないようにしておくことです。そのためには
環境変数 @code{TERM} を調べて下さい。それは接続時に @code{dumb} に設定
されます。

@vindex tramp-terminal-type
変数 @code{tramp-terminal-type} によりこの値を @code{dumb} に変更する
ことができます。

別のアプローチは @value{tramp} にこれらの質問を教えておくことです。変数
@code{tramp-actions-before-shell} および @code{tramp-multi-actions}
(マルチホップ接続の場合) を参照して下さい。


@item @file{.profile} 中の環境変数で、ユーザと同じ名前のものたち

frumple という名前のユーザが居たとして、変数 @code{FRUMPLE} をシェル環境
で設定している場合、不具合が起きるかもしれません。
@code{FRUMPLE_DIR} とかそのようなものに改名するのがよいでしょう。

奇妙な効果が実際に @value{tramp} ユーザから報告されています!


@item @file{.profile} 中の Non-Bourne コマンドたち

リモートホストにログインした後、@value{tramp} はコマンド @code{exec /bin/sh}
を発行します。 (実際にはコマンドはちょっと異なりますが。)
@code{/bin/sh} が実行される時に、いくつかの初期化ファイルが読み込まれます。
例えば @file{~/.shrc} や @file{~/.profile} です。

ここで、ログインシェルが @code{/bin/sh} ではなく、 bash や ksh といった
Bourne 的なシェルであった場合、人によっては @code{~/.shrc} や @code{~/.profile}.
にシェルの設定を書いているかもしれません。その場合に、Bourne でない構成物
がそれらのファイルに書かれている可能性があります。そうすると、@code{exec /bin/sh}
によって Bourne シェルはそれらを戻してしまいます。

例えば @file{~/.profile} ファイルに @code{export FOO=bar} と書いてあった
とすると、標準的な Bourne シェルはこの構文を理解できないので、この行に
到達するとシンタックスエラーを返します。

別の例としてはチルダ (@code{~}) 文字があります。例えば @code{$PATH} に
@file{~/bin} を付け加える場合です。 多くの Bourne シェルはこの文字を展開
せず、普通は名前がチルダ一文字のディレクトリは存在しないのでおかしなこと
が起こるでしょう。

これに対して何をすればよいのか?

一つの方法としては全てのリモートホスト上の @file{~/.shrc} と
@file{~/.profile} の中の全てが Bourne-互換であるようにすることです。
上の例では、@code{export FOO=bar} の代わりに @code{FOO=bar; export FOO}
と書けばよいでしょう。

別の方法としては、non-Bourne シェルの設定を別のファイルに書くことです。
例えば、bash はファイル @file{~/.bash_profile} があれば @file{~/.profile}
の代わりにそれを読み込みます。したがって bash ファンは全てのリモートホスト
上の @file{~/.profile} を @file{~/.bash_profile} に改名しておけば大丈夫です。

@value{tramp} の開発者はこの問題を回避したいと考えています。したがってこれに
関するアイデアがあればぜひ教えて下さい。しかしながら、これはそう単純では
ないと考えています: @code{exec /bin/sh} と呼ぶ前には、@value{tramp} はどの
種類のシェルと対話しているのか知らないのです。それは ksh や bash といった
Bourne 的なシェルであるかもしれませんし、csh から派生した tcsh のような
ものかもしれません。もしくは zsh や、はたまた rc であるかもしれません。
もしシェルがすでに Bourne 的なものであるなら @code{exec /bin/sh} の段階を
省略するのが懸命かもしれません。しかし、どうやってシェルが Bourne 的だと
知るのでしょうか?

@end table


@node Auto-save and Backup
@section Auto-save とバックアップの設定
@cindex auto-save
@cindex backup
@vindex backup-directory-alist

auto-save の説明は未完成です。

通常 Emacs はオリジナルのファイルと同じディレクトリにバックアップファ
イルを保存しますが、この挙動は変数 @code{backup-directory-alist} を通
して変更することができます。@value{tramp} を用いた接続においてこのことは予
期しない副作用をもたらす可能性があります。例えば全てのバックアップがデ
ィレクトリ @file{~/.emacs.d/backups/} に行くようになっていたとして、フ
ァイル @file{/su:root@@localhost:/etc/secretfile} を編集したとしましょ
う。その結果は、バックアップファイルは root ではなくあなたの所有となり、
したがってたとえそのつもりがなかったとしてもそれが他者から見てしまう可
能性があります。

@code{backup-directory-alist} が nil (デフォルト) であればそのような問
題はおこりません。

もしあなたがその変数をカスタマイズしたいなら、@value{tramp} のファイルに対
して特別な設定を行なうという回避法があります。例えば以下の記述により、
@value{tramp} のファイルに対して効果的に @code{backup-directory-alist} の効
果を消します:

@lisp
(require 'tramp)
(add-to-list 'backup-directory-alist
             (cons tramp-file-name-regexp nil))
@end lisp


@node Windows setup hints
@section Cygwin ssh にまつわる事柄
@cindex Cygwin, issues

この節はたくさんの仕事が必要です! どうか手伝って下さい。

@cindex method sshx with Cygwin
@cindex sshx method with Cygwin
もしあなたが Cygwin でインストールした ssh (インストーラで明示的に選択
する必要があります) を使っているなら、接続メソッドとして @code{sshx} を
選択するだけでマシンの外に出られるはずです。Cygwin のセットアップに
ついての情報は @uref{http://cygwin.com/faq/} にある彼らの FAQ で得る
ことができます。

@cindex method scpx with Cygwin
@cindex scpx method with Cygwin
もし @code{scpx} 接続メソッドを使いたいと思ったなら、Emacs が @code{c:/foo}
のような Windows ファイル名を伴なって @code{scp} を呼ぶ時に問題が起きる
かもしれません。Cygwin 版の @code{scp} は Windows ファイル名について知ら
ないので、それをホスト @code{c} 上のリモートファイル名と解釈してしまいます。

一つの可能な回避法としては、Windows ファイル名を Cygwin のファイル名に
変換するラッパースクリプトを書くことです。

別の回避法としては Emacs を Cygwin 上で動かすか、もしくは Cygwin 版の
Emacs を使うことがあると思います。

@cindex Cygwin and ssh-agent
@cindex SSH_AUTH_SOCK and Emacs on Windows
何らかの @code{ssh} に基づくメソッドを Windows 上で使いたい場合、
@code{ssh-agent} に関する問題に遭遇するかもしれません。このプログラム
を使うと、ログインの際に毎回パスフレーズを入力することを避けることが
できます (また、@code{scpx} メソッドは @code{ssh-agent} を使うことを
要求します。なぜならそれはパスワードやパスフレーズを入力させてくれない
からです)。しかしながら、Emacs をデスクトップショートカットから起動した
なら、環境変数 @code{SSH_AUTH_SOCK} は設定されないので、 Emacs そして
@value{tramp}、 そして @value{tramp} から起動される @code{ssh} および @code{scp} 
は @code{ssh-agent} と通信することができません。Emacs をシェルから起動
すればうまく動きます。

もし誰か Windows 上でデスクトップショートカットが恩恵を受けられるような、
@code{ssh-agent} の起動方法を知っていたら叫んで下さい。私は本当に Windows
については何も知らないのです@dots{}


@node Usage
@chapter @value{tramp} の使い方
@cindex using @value{tramp}

@value{tramp} をインストールすると、@value{tramp} は完全に透過的に動作します。
ログイン可能なリモートマシン上のファイルに、あたかもローカルファイル
のようにアクセスすることができます。

@value{tramp} では、formalized シンタックスを使いファイルを指定します。これは、
@value{ftppackagename} パッケージのシンタックスに似ています。

@cindex type-ahead
あなたを驚かせることが起こり得ます。 Emacs は全てのキー入力を憶えています。
したがって Emacs からのパスワードプロンプトを目にして @kbd{@key{RET}}
を一回でなく二回叩いた場合、二回目のキー入力は @value{tramp} が動作した後で
Emacs で処理されます。何故この先行入力が通常の挙動かと思うでしょう。
あなたは正しい、しかしリモートファイルを開くにはしばらくの時間がかかり、
接続が開かれるまでに30秒かかるかもしれないということに気付いて下さい。
おそらく30秒後にはそのキーを叩いたことをすでに忘れているでしょう!

@menu
* Filename Syntax::             @value{tramp} ファイル名のきまり
* Multi-hop filename syntax::   マルチホップファイル名のきまり
* Filename completion::         ファイル名補完
* Dired::                       Dired
@end menu


@node Filename Syntax
@section @value{tramp} ファイル名のきまり
@cindex filename syntax
@cindex filename examples

リモートマシン @var{machine} 上のファイル @var{localname} にアクセスす
るためには、ファイル名
@file{@value{prefix}@var{machine}@value{postfix}@var{localname}}.
を指定してください。これで、 @var{machine} に接続し、デフォルトメソッド
を使用してファイルが転送されます。@xref{Default Method}.

@value{tramp} のファイル名の例を以下に挙げます。

@table @file
@item @value{prefix}melancholia@value{postfix}.emacs
マシン @code{melancholia} 上のホームディレクトリにある @file{.emacs}を
編集します。

@item @value{prefix}melancholia.danann.net@value{postfix}.emacs
完全なホスト名(FQDN)を使い、上と同じファイルを編集します。

@item @value{prefix}melancholia@value{postfix}~/.emacs
これもまた同じファイルを編集します。@file{~} は、ローカルの場合と
同様に、リモートマシン上のホームディレクトリに展開されます。

@item @value{prefix}melancholia@value{postfix}~daniel/.emacs
マシン @code{melancholia} 上のユーザー @code{daniel} のホームディレクトリ
にあるファイル @file{.emacs} を編集します。@file{~<ユーザー>} 構文は
リモートマシン上のユーザーのホームディレクトリに展開されます。

@item @value{prefix}melancholia@value{postfix}/etc/squid.conf
マシン @code{melancholia} 上のファイル @file{/etc/squid.conf} を編集
します。

@end table

違う名前を使うように指定しない限り、@value{tramp} は現在のローカルなユーザ名
をログインのためのリモートユーザー名として使います。もし、違うユーザーで
ログインする必要がある場合は、ファイル名の一部としてユーザー名を指定する
ことができます。

指定したユーザーでリモートマシンにログインする必要がある場合、
@file{@value{prefix}@var{user}@@@var{machine}@value{postfix}/@var{path/to.file}}
というシンタックスを使用してください。つまり、 @code{melancholia} にユーザー
@code{daniel} として接続してホームディレクトリの @file{.emacs} を編集
する場合、@file{@value{prefix}daniel@@melancholia@value{postfix}.emacs}
を指定すればよいのです。

ファイル名の一部として、他のファイル転送メソッド(@pxref{Default Method})
を指定することもできます。
@ifset emacs
そうするには以下のようにして、ユーザ名、ホスト名より前にメソッドを書きます。
@file{@value{prefix}@var{method}@value{postfixsinglehop}}
(末尾のコロンに注意)。
@end ifset
@ifset xemacs
そうするには最初の @file{@value{prefix}} を
@file{@value{prefix}<method>@value{postfixsinglehop}}
で置き換えます。(末尾のスラッシュに注意!)
@end ifset
ユーザー、マシン、ファイルの指定は今までと同じです。

マシン @code{melancholia} に @code{daniel} として接続し、ファイル転送に
@option{ssh} メソッドを使い、ホームディレクトリの @file{.emacs} を編集する
ためには、ファイル名
@file{@value{prefix}ssh@value{postfixsinglehop}daniel@@melancholia@value{postfix}.emacs}
を指定します。


@node Multi-hop filename syntax
@section マルチホップファイル名のきまり
@cindex filename syntax for multi-hop files
@cindex multi-hop filename syntax

マルチホップファイル名のシンタックスは、当然のことながら、他の @value{tramp} 
のファイル名と若干異なります。以下に、マルチホップファイル名の例を
あげます。最初が Emacs のシンタックスで次が XEmacs のシンタックスによ
るものです:

@example
@value{prefix}multi@value{postfixsinglehop}rsh@value{postfixmultihop}out@@gate@value{postfixsinglehop}telnet@value{postfixmultihop}kai@@real.host@value{postfix}/path/to.file
@end example

これは非常に重要なので、ひとつひとつ説明しましょう。ファイル名は
3つの部分から成り、
@ifset emacs
各部はコロンで区切られます。
@end ifset
@ifset xemacs
各部はスラッシュと角括弧で区切られます。
@end ifset
最初のパート @file{@value{prefix}multi} はメソッドの指定です。
二番目のパートは
@file{rsh@value{postfixmultihop}out@@gate@value{postfixsinglehop}telnet@value{postfixmultihop}kai@@real.host}
でホップを指定します。最後のパートは @file{/path/to.file} で、リモート
ホスト上のファイル名を指定します。

最初と最後のパートは明白でしょう。@ref{Multi-hop Methods}に指定可能
なメソッドの一覧があります。

二番目のパートは、再びコンポーネントに、つまりホップたち(hops) に分割
されることがあります。上記のファイル名には、二つのホップたち、
@file{rsh@value{postfixmultihop}out@@gate} および
@file{telnet@value{postfixmultihop}kai@@real.host}
が含まれています。

それぞれのホップは、@emph{再び}(3つの)コンポーネント、
@dfn{ホップメソッド}、@dfn{ユーザー名}、@dfn{ホスト名}に分割されることが
ありまます。二番目、三番目のコンポーネントの意味は明白です。ホップメソッドは、
このホップでどのようなプログラムを使うかを意味しています。

最初のホップ @file{rsh@value{postfixmultihop}out@@gate} は、
ホスト @code{gate} にユーザー @code{out} としてログインするために
@command{rsh} を使うという意味です。二番目のホップ
 @file{telnet@value{postfixmultihop}kai@@real.host}@file{telnet@value{postfixmultihop}kai@@real.host}
は、このホストからホスト @code{real.host} にユーザー @code{kai}でログ
インするために @command{telnet} を使うという意味です。

@xref{Multi-hop Methods}. ここにホップメソッドの一覧があります。
変数 @code{tramp-multi-connection-function-alist} には、選択可能なホップ
メソッドのリストとそれらをどのように実行するかという情報が含まれています。
あなたが作ったメソッドをこの変数に追加してください。


@node Filename completion
@section ファイル名補完
@cindex filename completion

@value{tramp} のファイル名補完はリモートマシンのファイル名の補完に加えて
メソッド、ユーザ名およびマシン名(マルチホップメソッドたちは除く)に
対して働きます。

例えば @kbd{C-x C-f @value{prefix}t@key{TAB}} と入力すると
@value{tramp} は以下の選択肢を返します。

@example
@ifset emacs
@value{prefixsinglehop}telnet@value{postfixsinglehop}				   tmp/
@value{prefixsinglehop}toto@value{postfix}
@end ifset
@ifset xemacs
@value{prefixsinglehop}telnet@value{postfixsinglehop}				   @value{prefixsinglehop}toto@value{postfix}
@end ifset
@end example

@samp{@value{prefixsinglehop}telnet@value{postfixsinglehop}}
はメソッドの補完であり、
@ifset emacs
@samp{tmp/} はローカルマシン上のディレクトリ @file{/tmp} であり、
@end ifset
@samp{@value{prefixsinglehop}toto@value{postfix}}
は @value{tramp} がファイル @file{~/.ssh/known_hosts} から検出したホスト名
です(デフォルトメソッド @option{ssh} を使っている場合)。

続けて @kbd{e @key{TAB}} とすれば、ミニバッファは
@samp{@value{prefix}telnet@value{postfixsinglehop}}
と補完されます。次の @kbd{@key{TAB}} では @value{tramp} がファイル @file{/etc/hosts}
から検出した全てのマシン名を挙げます。例えば、

@example
@value{prefixsinglehop}telnet@value{postfixsinglehop}127.0.0.1@value{postfix}		   @value{prefixsinglehop}telnet@value{postfixsinglehop}192.168.0.1@value{postfix}
@value{prefixsinglehop}telnet@value{postfixsinglehop}localhost@value{postfix}		   @value{prefixsinglehop}telnet@value{postfixsinglehop}melancholia.danann.net@value{postfix}
@value{prefixsinglehop}telnet@value{postfixsinglehop}melancholia@value{postfix}
@end example

ここで希望のマシンを選択することができ、続けてそのマシン上のファイル名
を補完することができます。

ファイル名補完はリモートマシンからファイルリストを取り寄せる必要が
あるために、しばしばとても遅くなります。今の所 @value{tramp} はディレクトリ
リストをキャッシュしないので二回目のファイル名補完でもパフォーマンス
上の違いは現れません。

@value{tramp} が補完の解析に用いる設定ファイル (@pxref{Customizing Completion})
がユーザ名を提供した場合、それらのユーザ名も考慮されます。


@node Dired
@section Dired
@cindex dired

@value{tramp} は dired 上でも透過的に動作します。この強力なファイル管理
ツールを使い、インターネットを経由しアクセス可能なすべてのマシン上の
ファイルを管理できます。

ディレクトリツリーをブラウズしたい場合は、今のところファイル名の補完
より dired を使うほうが良いでしょう。dired は自身でキャッシュの仕組み
をもっているので、ファイル一覧を一度しか取得しません。


@node Bug Reports
@chapter バグや問題の報告
@cindex bug reports

@value{tramp} のバグや問題は、開発チームによってアクティブに解決されています。
仕様に関するリクエストや提案も歓迎します。

@value{tramp} メーリングリストは、@value{tramp} の情報を入手したり、問題の解決や、
一般的な議論、そしてこのパッケージに関係する話題へのアドバイスに最適
の場所です。

メーリングリストは @email{tramp-devel@@mail.freesoftware.fsf.org} です。
このアドレスにメッセージをを送るとすべての講読者に届きます。
これは講読のリクエストを送信するためのアドレスでは @emph{ありません}。

メーリングリストを講読するためのヘルプを入手するには、サブジェクトに
@samp{help} と書いたメールを管理用のアドレス
@email{tramp-devel-request@@mail.freesoftware.fsf.org} に送信してください。

@value{tramp} のバグ報告をする場合には、@kbd{M-x tramp-bug} を実行してください。
これは、あなたのシステムの詳細や @value{tramp} のバージョン情報を含むバッファ
を自動的に生成します。

バグ報告を提出する時には、問題を再現する手順、リモートマシンの設定、
もし存在するのであれば特殊な条件を、しつこいぐらい詳細に記述してく
ださい。もし可能なら、簡単な再現手順も記述してください。

もし、問題を再現するための簡単なテストケースがわかれば、それをバグ
報告に含めてください。これにより、開発チームがバグを突き止め、修正
するのが容易になります。


@node Frequently Asked Questions
@chapter よくある質問とその答
@cindex frequently asked questions
@cindex FAQ

@itemize @bullet
@item
最新の @value{tramp} はどこから入手できますか?

@value{tramp} は以下の URL で入手可能です

@noindent
@uref{http://savannah.nongnu.org/download/tramp/}

@noindent
また Savannah のプロジェクトページもあります。

@noindent
@uref{https://savannah.gnu.org/projects/tramp/}

@item
どのようなシステム上で動作しますか?

このパッケージは、Emacs 20 と Emacs 21 上で動作します。XEmacs 20 上では
問題があります。@file{tramp.el} のコメントを参照してください。Emacs 19 
で試した人がいるのかどうかは知りません。

このパッケージは Unix 上で動作するように設計されています。そしてリモート
側も Unix 風のシステムであることを期待しています。しかし、NT Emacs 上で
動作させることに成功した人が何人かいるようです。

以下の URL には、Tramp を NT で使うための情報があります; Joe Stoy
には情報の提供に対して深く感謝します:
@uref{ftp://ftp.comlab.ox.ac.uk/tmp/Joe.Stoy/}

上記はもっぱら古いバージョンの ssh へのパッチがおいてあります; Tom Roche
の Web page にも説明があります:
@uref{http://www4.ncsu.edu/~tlroche/plinkTramp.html}

??? XEmacs の情報は正しいのでしょうか?

??? 誰か、NT Emacs 上で動かすための情報を教えてください。たぶん、@command{ssh}
関係の問題があるのではないかと思います。

@item
@value{emacsname} で @value{ftppackagename} が起動されてしまいます

@ifset emacs
ftp メソッドによりファイルを要求すると、@value{tramp} によって
@value{ftppackagename} が自動的に読み込まれます。不幸なことにいくつかの
Lisp パッケージは @value{ftppackagename} ファイル名ハンドラを有効に
してしまいます。@kbd{C-h v file-name-handler-alist} とするとそれを確か
めることができます:

@example
file-name-handler-alist's value is 
(("^/[^/:]*\\'" . ange-ftp-completion-hook-function)
 ("^/[^/:]*[^/:.]:" . ange-ftp-hook-function)
 ("^/[^/]*$" . tramp-completion-file-name-handler)
 ("\\`/[^/:]+:" . tramp-file-name-handler)
 ("\\`/:" . file-name-non-special))
@end example

どのパッケージが @value{ftppackagename} を読み込ませているか調べて
ぜひバグレポートを出して下さい。

回避法としては、@file{~/.emacs} で @value{tramp} より先に @value{ftppackagename}
を require しておくことです。何故なら @value{tramp} は @code{file-name-handler-alist}
内の登録を整理するからです:

@lisp
;; @value{ftppackagename} を仮に require する
(require 'ange-ftp)
;; @value{tramp} が @code{file-name-handler-alist} を整理する
(require 'tramp)
@end lisp
@end ifset

@ifset xemacs
すべての古いバージョンの @value{tramp} が @value{emacsname} @value{emacsname}
を正しくサポートしているわけではありません。まず最初に、最新の @value{tramp}
がインストールされているかどうかを確認してください。

もし最新のバージョンなら、 @value{ftppackagename} ハンドラーが実行
されるための条件を正確に調べてください。もし可能なら、ブレークポイント
を @code{efs-ftp-path} に設定して、バグ報告と一緒にスタックトレースを
送ってください。これらの情報があると、開発者が何が間違っているのかを発
見することが容易になります。
@end ifset


@item
@value{tramp} を使うとファイル名の補完ができません

リモートマシンにログインした時に、@command{ls} の出力が色付きになって
いませんか? もし、そうなら、それが原因です。

@command{ls} は、端末エミュレーターが色を変更するための @acronym{ANSI} 
エスケープシークエンスを出力します。しかしながら、このエスケープ
シークエンスは @value{tramp} を混乱させます。

リモートマシン上の @file{.bashrc}、@file{.profile} あるいは同じような
設定ファイルに、@option{--color=yes} または @option{--color=auto}
が追加された設定の alias があるはずです。

この alias を削除し、新しくログインした時の @command{ls} の出力が
色付きで表示され @emph{ない} ことを確認してください。もし、これでも
ファイル名の補完が正常に動作しない場合は、@value{tramp} 開発者にバグ報告
をしてください。


@item
巨大なディレクトリの中ではファイル名の補完が動作しません

@value{tramp} はいくつかのオペレーションで globbing を使用します。(globbing
とは、`*.c' のようなワイルドカード展開のためにシェルを使うことです)
これは、たくさんのファイルが存在するディレクトリでは長いコマンドライン
を作ります。いくつかのシェルでは長いコマンドラインをけずりとったり、
あるいは globbing 自身を処理できません。

リモートホスト側に巨大なディレクトリがある場合は、
@samp{ls -d * ..?* > /dev/null} のようなコマンドを実行し、ハングするか
どうかを確認してください。注意する必要があるのは、最初に正しいシェル、
@command{/bin/sh}、@command{ksh} あるいは @command{bash}、つまり tilde の
展開をサポートするシェルから試すべきだという事です。


@item
@value{tramp} はどのような種類のシステムで動作しますか

@value{tramp} は、リモートシステムが Unix 風のシステムである事を前提にして
います。また、ローカルシステムも Unix 風のシステムのほうが望ましいで
しょう。しかし、すこし修正すれば、@value{tramp} は NT 上でも動作するはずです。


@item
@value{tramp} のファイル転送が完了した時に通知させるにはどうすればいいでしょうか?

以下のコードを、@file{~/.emacs} に追加してください。これで、リモート
ホストに対する読み書きの後に、Emacs が beep 音をならしてくれます。

@lisp
(defadvice tramp-handle-write-region
  (after tramp-write-beep-advice activate)
 " make tramp beep after writing a file."
 (interactive)
 (beep))
(defadvice tramp-handle-do-copy-or-rename-file
  (after tramp-copy-beep-advice activate)
 " make tramp beep after copying a file."
 (interactive)
 (beep))
(defadvice tramp-handle-insert-file-contents
  (after tramp-copy-beep-advice activate)
 " make tramp beep after copying a file."
 " make tramp beep after copying a file."
 (interactive)
 (beep))
@end lisp


@item
リモートホストの @file{~/.sh_history} というファイルが肥大し続けていま
す。これは何ですか?

@value{tramp} はティルダ展開の為に、しばしばリモートホストで @code{ksh} を
起動します。たぶん @code{ksh} はデフォルトで履歴を保存します。@value{tramp}
は履歴の保存を停止しようと試みますが、あなたが手助けをする必要がある
かもしれません。例えば、あなたの @file{.kshrc} にこれを入れてください:

@example
if [ -f $HOME/.sh_history ] ; then
   /bin/rm $HOME/.sh_history
fi
if [ "$@{HISTFILE-unset@}" != "unset" ] ; then
   unset HISTFILE
fi
if [ "$@{HISTSIZE-unset@}" != "unset" ] ; then
   unset HISTSIZE
fi
@end example


@item @value{tramp} が 500 文字を越える文字列を正しく転送しません。

いくつかの稀なシステムでは、@code{process-send-string} の実装が
長い文字列に対して壊れています。この場合、変数 @code{tramp-chunksize}
を 500 にカスタマイズします。これが必要かどうかをどうやって知るかは
@code{tramp-chunksize} の説明を見て下さい。

@end itemize


@c For the developer
@node Version Control
@chapter リモートバージョンコントロールの内部動作
@cindex Version Control

@value{ftppackagename} と異なり、@value{tramp} は、リモートマシン上のシェルを実行
します。したがって、@value{tramp} を使いアクセスしたファイルのバージョン
管理をおこなう事ができます。

バージョン管理をおこなうバイナリが、リモートマシンにインストールされて
いなければなりません。そして、@var{tramp-remote-path} で指定された
ディレクトリに置かれて、アクセス可能でなければなりません。

バージョン管理システムの透過的な統合は、@value{tramp} のもっとも価値のある
機能のひとつです。しかし、まだ完全にはほど遠い状態です。システムの透過
性を向上させるための作業が続けられています。

@menu
* Version Controlled Files::    ファイルがバージョン管理されているかどうかの判断
* Remote Commands::             リモートマシン上でのバージョン管理コマンドの実行
* Changed workfiles::           作業ファイルの変更の発見
* Checking out files::          作業ファイルのリポジトリからの取得
* Miscellaneous Version Control::  その他バージョン管理システムに関係する事
@end menu


@node Version Controlled Files
@section ファイルがバージョン管理されているかどうかの判断

VC パッケージは、ディスク上のマスターファイルの存在をもとに、指定された
ファイルがバージョン管理システムの管理下にあるかどうかを判断します。
これらのファイルのテストは、標準的な @value{tramp} の仕組みを使いリモート
マシン上で実行されます。


@node Remote Commands
@section リモートマシン上のバージョン管理コマンドの実行

バージョン管理システムのコマンドの実行を横取りすることのできる VC 用の 
hook は存在しません。@code{call-process} の仕組みを使い、
関数呼び出しが発生します。関数は @code{shell-command} より、若干
効率的ですが、リモートでコマンドを実行するための hook は用意されていません。

とりあえず動作させるために、関数 @code{vc-do-command} と 
@code{vc-simple-command} に、@value{tramp} を経由しアクセスされたファイルへの
オペレーションのためのリクエストを横取することが通知されます。

リモートファイルの場合、ローカルマシンと同じ機能を提供するために、
@code{shell-command} インターフェースが、いくつかのラッパーコードと
共に使用されます。


@node Changed workfiles
@section 作業ファイルの変更の発見

今のところ、リモートマシン上のファイルの mtime を取得する移植性の高い
方法は存在しません。@code{vc-workfile-unchanged-p} 関数に、リモート
ファイルのために @value{tramp} の関数の呼び出しが通知されます。

@code{tramp-vc-workfile-unchanged-p} 関数は、作業ファイルとバージョン
管理マスタファイルの変更点を調べるために VC の diff 機能を使用します。

これを実現するためには、リモートでのシェルコマンドが実行可能でなれば
なりません。この処理は、ローカルファイルで使われる mtime の取得より
重い処理です。残念ながら、移植性の高い解決方法が見つかるまでは、リモート
バージョン管理のコストはこのままでしょう。


@node Checking out files
@section 作業ファイルのリポジトリからの取得

デフォルトでは、VC はリモートファイルをチェックし、リポジトリからチェック
アウトされたファイルがある場合は、チェックアウトをおこないません。この問題
を解決するために、関数 @code{vc-checkout} は @value{tramp} ファイルを区別し、
バージョン管理をおこなうことを可能にします。


@node Miscellaneous Version Control
@section その他バージョン管理システムに関係する事

こまかな実装の詳細、その他。

@menu
* Remote File Ownership::       VC がワークファイルのオーナーを調べる方法
* Back-end Versions::           VC が RCS のバージョンを調べる方法
@end menu


@node Remote File Ownership
@subsection VC がワークファイルのオーナーを調べる方法

Emacs は、任意のユーザー ID の値とログイン名をマッピングするのと同様に、
現在のユーザーのログイン名をかえす関数 @code{user-full-name} を用意して
います。VC は、いくつかの状況で、ワークファイルのオーナーの uid からログ
イン名へのマップ機能を使用します。

これは、リモートシステムが異なるログインセットを持つ場合には、あきらか
に正しく動作しません。したがって、uid に対応するログイン名の決定をリモート
マシンにおこなわせる必要があります。

残念ながら、@code{NIS}、@code{NIS+}そして @code{NetInfo} のような、
分散管理システム を使う場合、シンプルで、信頼性があり、移植性の高い
マッピングの方法は存在しません。

ありがたい事に、uid からログイン名へのマッピングに依存する VC のコードは、
関数 @code{vc-file-owner} ひとつだけです。この関数は、ファイルのオーナー
のログイン名を文字列として返します。

ログイン名を決定するために、この関数に、リモートマシン上の @command{ls} 
の出力を使用することが通知されます。uid からログイン名のマッピングを、
私よりそれらについて良く知っているはずのリモートシステムに委譲します。


@node Back-end Versions
@subsection VC が RCS のバージョンを調べる方法

VC は、どのリリースのバージョン管理システムのバイナリを使っているかを
知る必要があります。これは、VC がサポートしているすべての機能を、古い
バージョンの@command{rcs(1)}、@command{cvs(1)}、@command{sccs(1)}が提供
しているわけでは無いからです。

VC のデフォルトの実装では、最初に必要になった時に、この値を決定します。
これは、必要になった時に毎回プロセスを実行し、その出力をパースすることの
オーバーヘッドをさけるためです。

いかし、リモートのバージョン管理システムの事が関係してくると、人生は
それほど簡単ではありません。リモートマシンはそれぞれ、異なるバージョン
のバージョン管理ツールをもっています。これが困難な間は、存在しない機能
が、リモートで使用されないことを保証する必要があります。

この問題を解決するために、現在の @value{tramp} は、バージョン管理ツールの
バージョン番号を @value{tramp} バッファ毎にローカルな変数にし、新しい
ファイルを開くたびにVC にこの値を決定させるという力ずくのアプローチ
を採用しています。

これはあきらかに性能に影響します。ありがたいことに、VC によっておこなわれる
ほとんどの処理は、実際にはリモートのバージョンを知ることを必要としません。
したがって、それほど問題になりません。

最終的には、これらの変数は @value{tramp} によってシステム毎に調べられ、
その結果は性能を改善するためにキャッシュされるようになるでしょう。


@node Files directories and localnames
@chapter ファイル名、ディレクトリ、ローカル名がどのように変換され(mangled)、管理されるか

@menu
* Localname deconstruction::         ローカル名の分解
@end menu


@node Localname deconstruction
@section ローカル名の分解

@value{tramp} のファイル名は普通のファイル名とは明らかに異なっています。
したがって、lisp の関数 @code{file-name-directory} と 
@code{file-name-nondirectory} は、@value{tramp} パッケージ内で上書きされて
います。

関数の置き換えはシンプルかつ適切な方法です。ファイル名を分解し、
ローカル名に対してオリジナルのハンドラーがよばれます。そして、
その結果をもとに @value{tramp} ファイル名が再構成されます。

これにより、@value{tramp} ファイル名の情報を扱う場合も、プラットホーム固有の
オリジナルハンドラーのハックは有効です。


@node Issues
@chapter 検討課題と決定事項

@itemize @bullet
@item uuencode メソッドがいつも動作するわけではありません

@value{tramp} の設計上の理由で、符号化と復号化をおこなうプログラムは標準
入力から読み込み、標準出力に書き込む必要があります。いくつかのシステム
では、@code{uudecode -o -} で標準入力から読み込み、復号化されたファイル
を標準出力に書き込みます。他のシステムでは、@code{uudecode -p} が同じ
動作をします。しかし、いくつかのシステムの uudecode の実装では、これら
のことが全くできません。これらの uudecode の実装に、標準出力に書き込む
ために適切なパラメータを渡して呼ぶことは不可能です。

もちろん、これを回避する事は可能です。テンポラリファイル名を追加する
ために @code{begin foo 644} 行を書きかえれば、@code{uudecode} を呼ぶこと
ができます。そしてテンポラリファイルを表示し削除します。

しかし、この方法はあまりにも信頼性が低いため、いくつかのシステムでは
uuencode メソッドを使用できないままにしておく事にしました。

@item @value{tramp} は XEmacs 20 上で動きません

これは、XEmacs 20 に存在しないマクロ @code{with-timeout} を使っている
からです。私は、エミュレーションのためのマクロを @value{tramp} に追加する
ことに、あまり乗り気ではありません。しかし、XEmacs 20 ユーザーの誰かが
積極的に実装とテストをしたいと考えているのであれば、私かメーリングリスト
に連絡してください。

@item @value{tramp} ファイル名のシンタックスが Emacs と XEmacs で違います。

Emacs のメンテナ達は、ユーザが新しいシンタックスを勉強する必要がないよ
うに Ange-FTP と @value{tramp} で統一されたファイル名シンタックスを使いたい
と望んでいます。

XEmacs のメンテナにとっては、統一されたファイル名シンタックスを用いる
ことによる利益よりもそのことによる問題の方が大きいです。
XEmacs のパッケージシステムはパッケージをダウンロードするのに EFS を
使います。したがって明らかに EFS は最初からインストールされているはず
です。もしファイル名が統一されていたとすると、@value{tramp} もまた最初から
インストールされている必要があります。

@end itemize

@node Concept Index
@comment node-name,    next,  previous,      up
@unnumbered Concept Index
@printindex cp
@contents
@c End of tramp_ja.texi - the TRAMP User Manual
@bye

@c TODO
@c
@c * Say something about the .login and .profile files of the remote
@c   shells.
@c * Explain how tramp.el works in principle: open a shell on a remote
@c   host and then send commands to it.
@c * Mention that bookmarks are a cool feature to go along with Tramp.
@c * Make terminology "inline" vs "out-of-band" consistent.
@c   It seems that "external" is also used instead of "out-of-band".

@c * M. Albinus
@c ** Use `filename' resp. `file name' consistently.
@c ** Use `host' resp. `machine' consistently.
@c ** Consistent small or capitalized words especially in menues.
