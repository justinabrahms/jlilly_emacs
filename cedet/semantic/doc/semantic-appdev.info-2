This is semantic-appdev.info, produced by makeinfo version 4.3 from
app-dev-guide.texi.

This manual documents Application Development with Semantic.

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007 Eric M.
Ludlam Copyright (C) 2001, 2002, 2003, 2004 David Ponce Copyright (C)
2002, 2003 Richard Y. Kim

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with the Invariant Sections being list their titles,
     with the Front-Cover Texts being list, and with the Back-Cover
     Texts being list.  A copy of the license is included in the
     section entitled "GNU Free Documentation License".
   
INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Semantic Application Writer's guide: (semantic-appdev).
END-INFO-DIR-ENTRY

   This file documents Application Development with Semantic.
_Infrastructure for parser based text analysis in Emacs_

   Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004 Eric M. Ludlam,
David Ponce, and Richard Y. Kim


File: semantic-appdev.info,  Node: Tags at Point,  Next: Tag Decoration,  Prev: Searching Tag Tables,  Up: Top

Tags at Point
*************

When you need to get the tag the cursor is on, there is a more
efficient mechanism than using `semantic-brute-find-tag-by-position'.
This mechanism directly queries the overlays the parsing step leaves in
the buffer.  This provides for very rapid retrieval of what function or
variable the cursor is currently in.

These functions query the current buffer's overlay system for tags.

 - Function: semantic-find-tag-by-overlay &optional positionormarker
          buffer
     Find all tags covering POSITIONORMARKER by using overlays.  If
     POSITIONORMARKER is `nil', use the current point.  Optional BUFFER
     is used if POSITIONORMARKER is a number, otherwise the current
     buffer is used.  This finds all tags covering the specified
     position by checking for all overlays covering the current spot.
     They are then sorted from largest to smallest via the start
     location.


     *Compatibility*: `semantic-find-tag-by-overlay' introduced in
     semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-overlay' which is now obsolete.

 - Function: semantic-find-tag-by-overlay-in-region start end &optional
          buffer
     Find all tags which exist in whole or in part between START and
     END.  Uses overlays to determine positin.  Optional BUFFER
     argument specifies the buffer to use.


     *Compatibility*: `semantic-find-tag-by-overlay-in-region'
     introduced in semantic version 2.0 supercedes
     `semantic-find-nonterminal-by-overlay-in-region' which is now
     obsolete.

 - Function: semantic-find-tag-by-overlay-next &optional start buffer
     Find the next tag after START in BUFFER.  If START is in an
     overlay, find the tag which starts next, not the current tag.

 - Function: semantic-find-tag-by-overlay-prev &optional start buffer
     Find the next tag before START in BUFFER.  If START is in an
     overlay, find the tag which starts next, not the current tag.

 - Function: semantic-current-tag
     Return the current tag in the current buffer.  If there are more
     than one in the same location, return the smallest tag.  Return
     `nil' if there is no tag here.


     *Compatibility*: `semantic-current-tag' introduced in semantic
     version 2.0 supercedes `semantic-current-nonterminal' which is now
     obsolete.

 - Function: semantic-current-tag-parent
     Return the current tags parent in the current buffer.  A tag's
     parent would be a containing structure, such as a type containing
     a field.  Return `nil' if there is no parent.


     *Compatibility*: `semantic-current-tag-parent' introduced in
     semantic version 2.0 supercedes
     `semantic-current-nonterminal-parent' which is now obsolete.


File: semantic-appdev.info,  Node: Tag Decoration,  Next: Tag Sorting,  Prev: Tags at Point,  Up: Top

Tag Decoration
**************

Tags can be decorated in different ways.  One way a user can control it
is through `semantic-decoration-mode'.  *note (Tag Decoration
Mode)semantic-user::

Applications can use the same routines to decorate tags as well.

* Menu:

* Tag Highlighting::            Highlighting a tag
* Tag Visible Properties::      Invisible, intangible and read only
* Tag Secondary Overlays::      Decorating parts of a tag text
* Tag Folding::                 Visibly Folding up tags


File: semantic-appdev.info,  Node: Tag Highlighting,  Next: Tag Visible Properties,  Up: Tag Decoration

Highlighting
============

 - Function: semantic-highlight-tag tag &optional face
     Specify that TAG should be highlighted.  Optional FACE specifies
     the face to use.

     *Compatibility*: `semantic-highlight-tag' introduced in semantic
     version 2.0 supercedes `semantic-highlight-token' which is now
     obsolete.

 - Function: semantic-unhighlight-tag tag
     Unhighlight TAG, restoring it's previous face.

     *Compatibility*: `semantic-unhighlight-tag' introduced in semantic
     version 2.0 supercedes `semantic-unhighlight-token' which is now
     obsolete.

 - Function: semantic-momentary-highlight-tag tag &optional face
     Highlight TAG, removing highlighting when the user hits a key.
     Optional argument FACE is the face to use for highlighting.  If
     FACE is not specified, then `highlight' will be used.

     *Compatibility*: `semantic-momentary-highlight-tag' introduced in
     semantic version 2.0 supercedes
     `semantic-momentary-highlight-token' which is now obsolete.

The highlighting routines do their work by changing the face property
of the tag overlay.  The raw routine is:

 - Function: semantic-set-tag-face tag face
     Specify that TAG should use FACE for display.

     *Compatibility*: `semantic-set-tag-face' introduced in semantic
     version 2.0 supercedes `semantic-set-token-face' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Visible Properties,  Next: Tag Secondary Overlays,  Prev: Tag Highlighting,  Up: Tag Decoration

Changing a tag's visible properties
===================================

You can give a tag other properties as well, such as making it
invisible or intangible.  You can control how code is edited
programatically through these routines.

 - Function: semantic-set-tag-invisible tag &optional visible
     Enable the text in TAG to be made invisible.  If VISIBLE is
     non-`nil', make the text visible.

     *Compatibility*: `semantic-set-tag-invisible' introduced in
     semantic version 2.0 supercedes `semantic-set-token-invisible'
     which is now obsolete.

 - Function: semantic-tag-invisible-p tag
     Return non-`nil' if TAG is invisible.

     *Compatibility*: `semantic-tag-invisible-p' introduced in semantic
     version 2.0 supercedes `semantic-token-invisible-p' which is now
     obsolete.

 - Function: semantic-set-tag-intangible tag &optional tangible
     Enable the text in TAG to be made intangible.  If TANGIBLE is
     non-`nil', make the text visible.  This function does not have
     meaning in XEmacs because it seems that the extent 'intangible'
     property does not exist.

     *Compatibility*: `semantic-set-tag-intangible' introduced in
     semantic version 2.0 supercedes `semantic-set-token-intangible'
     which is now obsolete.

 - Function: semantic-tag-intangible-p tag
     Return non-`nil' if TAG is intangible.  This function does not
     have meaning in XEmacs because it seems that the extent
     'intangible' property does not exist.

     *Compatibility*: `semantic-tag-intangible-p' introduced in
     semantic version 2.0 supercedes `semantic-token-intangible-p'
     which is now obsolete.

 - Function: semantic-set-tag-read-only tag &optional writable
     Enable the text in TAG to be made read-only.  Optional argument
     WRITABLE should be non-`nil' to make the text writable instead of
     read-only.

     *Compatibility*: `semantic-set-tag-read-only' introduced in
     semantic version 2.0 supercedes `semantic-set-token-read-only'
     which is now obsolete.

 - Function: semantic-tag-read-only-p tag
     Return non-`nil' if the current TAG is marked read only.

     *Compatibility*: `semantic-tag-read-only-p' introduced in semantic
     version 2.0 supercedes `semantic-token-read-only-p' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Secondary Overlays,  Next: Tag Folding,  Prev: Tag Visible Properties,  Up: Tag Decoration

Secondary Overlays
==================

Each tag which is being visited in a buffer has one overlay.  This
overlay is used to track where the tag is while a user is editing, and
can also be used for fast tag identification, and some simple
decoration techniques.

A secondary overlay associates a new overlay object with a tag which
does not cover the entire body of a tag.  You can then put visible
features on that overlay to decorate portions of a tag.  This is how
tag boundaries are drawn.

Creation and Deletion
---------------------

 - Function: semantic-tag-create-secondary-overlay tag &optional
          link-hook
     Create a secondary overlay for TAG.  Returns an overlay.  The
     overlay is also saved in TAG.  LINK-HOOK is a function called
     whenever TAG is to be linked into a buffer.  It should take TAG
     and OVERLAY as arguments.  The LINK-HOOK should be used to
     position and set properties on the generated secondary overlay.

 - Function: semantic-tag-delete-secondary-overlay tag
          overlay-or-property
     Delete from TAG the secondary overlay OVERLAY-OR-PROPERTY.  If
     OVERLAY-OR-PROPERTY is an overlay, delete that overlay.  If
     OVERLAY-OR-PROPERTY is a symbol, find the overlay with that
     property.

Queries
-------

 - Function: semantic-tag-get-secondary-overlay tag property
     Return secondary overlays from TAG with PROPERTY.  PROPERTY is a
     symbol and all overlays with that symbol are returned..

 - Function: semantic-tag-secondary-overlays tag
     Return a list of secondary overlays active on TAG.

Linking and Unlinking
---------------------

When a tag's file is put in a buffer, that tag is "linked" into the
buffer.  When the buffer is deleted, the tag is "unlinked".  This
process adds and removes the default overlay on the tag.  Secondary
overlays use `semantic-tag-add-hook' and `semantic-tag-remove-hook' too
apply link and unlink hooks.

This allows the secondary overlays to be automatically removed or added
by the seconary overlay system whenever a tag's file goes in or out of
a buffer.


File: semantic-appdev.info,  Node: Tag Folding,  Prev: Tag Secondary Overlays,  Up: Tag Decoration

Folding
=======

Using secondary overlays, a set of tag folding routines are made
available.  These routines are similar to the tag visible properties.

 - Function: semantic-set-tag-folded tag &optional folded
     Fold TAG, such that only the first line of text is shown.
     Optional argument FOLDED should be non-`nil' to fold the tag.
     `nil' implies the tag should be fully shown.

 - Function: semantic-tag-folded-p tag
     Non-`nil' if TAG is currently folded.


File: semantic-appdev.info,  Node: Tag Sorting,  Next: Tag Completion,  Prev: Tag Decoration,  Up: Top

Tag Sorting
***********

Sometimes it is important to reorganize a tag stream into a form that
is better for display to a user.  It is important to not use functions
with side effects that could effect the tag cache.

There are some existing utility functions which will reorganize the tag
list for you.

 - Function: semantic-unique-tag-table tags
     Scan a list of TAGS, removing duplicates.  This must first sort
     the tags by position ascending.  TAGS are removed only if they are
     equivalent, as can happen when multiple tag sources are scanned.

 - Function: semantic-unique-tag-table-by-name tags
     Scan a list of TAGS, removing duplicate names.  This must first
     sort the tags by name alphabetically ascending.

 - Function: semantic-bucketize tags &optional parent filter
     Sort TAGS into a group of buckets based on tag class.  Unknown
     classes are placed in a Misc bucket.  Type bucket names are
     defined by either `semantic-symbol->name-assoc-list'.  If PARENT
     is specified, then TAGS belong to this PARENT in some way.  This
     will use `semantic-symbol->name-assoc-list-for-type-parts' to
     generate bucket names.  Optional argument FILTER is a filter
     function to be applied to each bucket.  The filter function will
     take one argument, which is a list of tokens, and may re-organize
     the list with side-effects.

 - Variable: semantic-bucketize-tag-class
     Function used to get a symbol describing the class of a tag.  This
     function must take one argument of a semantic tag.  It should
     return a symbol found in `semantic-symbol->name-assoc-list' which
     "semantic-bucketize" uses to bin up tokens.  To create new bins
     for an application augment `semantic-symbol->name-assoc-list', and
     `semantic-symbol->name-assoc-list-for-type-parts' in addition to
     setting this variable (locally in your function).

 - Function: semantic-adopt-external-members tags
     Rebuild TAGS so that externally defined members are regrouped.
     Some languages such as C++ and CLOS permit the declaration of
     member functions outside the definition of the class.  It is
     easier to study the structure of a program when such methods are
     grouped together more logically.

     This function uses "semantic-tag-external-member-p" to determine
     when a potential child is an externally defined member.

     Note: Applications which use this function must account for token
     types which do not have a position, but have children which *do*
     have positions.

     Applications should use `semantic-mark-external-member-function'
     to modify all tags which are found as externally defined to some
     type.  For example, changing the token type for generating extra
     buckets with the bucket function.

 - Variable: semantic-orphaned-member-metaparent-type
     In "semantic-adopt-external-members", the type of `'type' for
     metaparents.  A metaparent is a made-up type semantic token used
     to hold the child list of orphaned members of a named type.

 - Variable: semantic-mark-external-member-function
     Function called when an externally defined orphan is found.  By
     default, the token is always marked with the `adopted' property.
     This function should be locally bound by a program that needs to
     add additional behaviors into the token list.  This function is
     called with two arguments.  The first is TOKEN which is a shallow
     copy of the token to be modified.  The second is the PARENT which
     is adopting TOKEN.  This function should return TOKEN (or a copy
     of it) which is then integrated into the revised token list.


File: semantic-appdev.info,  Node: Tag Completion,  Next: Override Methods,  Prev: Tag Sorting,  Up: Top

Tag Completion
**************

Often time, it is useful to ask the user for the name of some tag.
This can be as simple as just prompting for a name, but often time, the
semantics can be quite complex.  If two tags have the same name, which
do you choose?

Semantic provides a completion engine for prompting for tags by name,
and providing fancy ways to display completion lists that allow the
user to choose a tag if several have the same name.

To use a completion function in your interactive function, you can
augment the "interactive" command like this:

     (defun my-function (tag)
        "Do something to TAG."
        (interactive (list (my-completion-function "Tag: ")))
        ...)

* Menu:

* Tag Completion Convenience Functions::  Provided functions
* Custom Tag Completion Functions::  Build your own completion function
* Old Tag Completion::          Completion functions from older releases


File: semantic-appdev.info,  Node: Tag Completion Convenience Functions,  Next: Custom Tag Completion Functions,  Up: Tag Completion

Tag Completion Convenience Functions
====================================

There are some pre written completion functions that can be used in your
programs.

 - Function: semantic-complete-read-tag-buffer-deep prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current buffer.  Available tags are
     from the current buffer, at any level.  Completion options are
     presented in a traditional way, with highlighting to resolve
     same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to story
     the history in.

 - Function: semantic-complete-read-tag-project prompt &optional
          default-tag initial-input history
     Ask for a tag by name from the current project.  Available tags
     are from the current project, at the top level.  Completion
     options are presented in a traditional way, with highlighting to
     resolve same-name collisions.  PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default
     value.  If INITIAL-INPUT is non-`nil', insert it in the minibuffer
     initially.  HISTORY is a symbol representing a variable to store
     the history in.

 - Function: semantic-complete-read-tag-analyzer prompt &optional
          context history
     Ask for a tag by name based on the current context.  The function
     "semantic-analyze-current-context" is used to calculate the
     context.  "semantic-analyze-possible-completions" is used to
     generate the list of possible completions.  PROMPT is the first
     part of the prompt.  Additional prompt is added based on the
     contexts full prefix.  CONTEXT is the semantic analyzer context to
     start with.  HISTORY is a symbol representing a variable to stor
     the history in.  usually a default-tag and initial-input are
     available for completion prompts.  these are calculated from the
     CONTEXT variable passed in.

 - Function: semantic-complete-inline-analyzer context
     Complete a symbol name by name based on the current context.  This
     is similar to `semantic-complete-read-tag-analyze', except that
     the completion interaction is in the buffer where the context was
     calculated from.  CONTEXT is the semantic analyzer context to
     start with.  See `semantic-complete-inline-tag-engine' for details
     on how completion works.


File: semantic-appdev.info,  Node: Custom Tag Completion Functions,  Next: Old Tag Completion,  Prev: Tag Completion Convenience Functions,  Up: Tag Completion

Custom Tag Completion Functions
===============================

There aren't many built in completion functions, but there are many
parts that can be put together into custom completion functions.

A completion function is built up of three important parts.

Tag Collection
     Something that selects tags, and provides some list of tags
     available, such as all functions, or all classes named "bob".

Typing and selecting
     The prompt where you can type in the name of a tag.

Displaying possible completion values
     A mechanism for displaying completion lists.

There is one typing and selecting routine that can be used to create
your custom completion prompt.

 - Function: semantic-complete-read-tag-engine collector displayor
          prompt default-tag initial-input history
     Read a semantic tag, and return a tag for the selection.  Argument
     COLLECTOR is an object which can be used to to calculate a list of
     possible hits.  See `semantic-completion-collector-engine' for
     details on COLLECTOR.  Argumeng DISPLAYOR is an object used to
     display a list of possible completions for a given prefix.
     See`semantic-completion-display-engine' for details on DISPLAYOR.
     PROMPT is a string to prompt with.  DEFAULT-TAG is a semantic tag
     or string to use as the default value.  If INITIAL-INPUT is
     non-`nil', insert it in the minibuffer initially.  HISTORY is a
     symbol representing a variable to story the history in.

As you can see, this takes one "collector", and one "displayor".  These
are objects created for this prompt at runtime.  The completion engine
then uses to perform their tasks.

For example:

     (defun semantic-complete-read-tag-buffer-deep (prompt &optional
     						      default-tag initial-input history)
       "Ask for a tag by name from the current buffer.
     PROMPT is a string to prompt with.
     DEFAULT-TAG is a semantic tag or string to use as the default value.
     If INITIAL-INPUT is non-nil, insert it in the minibuffer initially.
     HISTORY is a symbol representing a variable to story the history in."
       (semantic-complete-read-tag-engine
        (semantic-collector-buffer-deep prompt :buffer (current-buffer))
        (semantic-displayor-traditional-with-focus-highlight "simple")
        ;;(semantic-displayor-tooltip "simple")
        prompt
        default-tag
        initial-input
        history)
       )

* Menu:

* Tag Collectors::
* Tag Displayors::


File: semantic-appdev.info,  Node: Tag Collectors,  Next: Tag Displayors,  Up: Custom Tag Completion Functions

Tag Collectors
--------------

A tag collector is an object that inherits from
"semantic-collector-abstract".  A new collector is needed for each
specialized type of prompt that draws from a different selection of
tags.

You can have a collector that satisfies multiple purposes using slots
filled in the initializer for that object.

Collectors inherit from some of the following:

 - Type: semantic-collector-abstract
     Root class for completion engines.  The baseclass provides basic
     functionality for interacting with a completion displayor object,
     and tracking the current progress of a completion.

 - Type: semantic-collector-buffer-abstract
     Root class for per-buffer completion engines.  These collectors
     track themselves on a per-buffer basis.

 - Type: semantic-collector-project-abstract
     Root class for project wide completion engines.  Uses semanticdb
     for searching all tags in the current project.

Available instantiable classes are:

 - Type: semantic-collector-buffer-deep
     Completion engine for tags in the current buffer.  When searching
     for a tag, uses semantic  deep searche functions.  Basics search
     only in the current buffer.

 - Type: semantic-collector-project
     Completion engine for tags in a project.

 - Type: semantic-collector-project-brutish
     Completion engine for tags in a project.

 - Type: semantic-collector-analyze-completions
     Completion engine that uses the context analyzer to provide
     options.  The only options available for completion are those
     which can be logically inserted into the current context.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Tag Displayors,  Prev: Tag Collectors,  Up: Custom Tag Completion Functions

Tag Displayors
--------------

When a user is interacting with the prompt, and requests completion,
those tags are drawn from the collector.  If the user asks for a list
of completion by hitting a complete key twice, then the list of
completions heeds to be displayed in some way.

Displayors can be used to manage the display of all tags currently
available, AND often needs to be used to focus one one particular tag
of many in a visible way.

All displayors inherit from the displayor baseclass that defines the
default behaviors:

 - Type: semantic-displayor-abstract
     Manages the display of some number of tags.  Provides the basics
     for a displayor, including interacting with a collector, and
     tracking tables of completion to display.

 - Type: semantic-displayor-focus-abstract
     A displayor which has the ability to focus in on one tag.
     Focusing is a way of differentiationg between multiple tags which
     have the same name.

Distinct implementations of displayors include:

 - Type: semantic-displayor-traditional
     Traditional display mechanism for a list of possible completions.
     Completions are showin in a new buffer and listed with the ability
     to click on the items to aid in completion.

 - Type: semantic-displayor-traditional-with-focus-highlight
     A traditional displayor which can focus on a tag by showing it.
     Same as `semantic-displayor-traditional', but with selection
     between multiple tags with the same name done by 'focusing' on the
     source location of the different tags to differentiate them.


 - Type: semantic-displayor-tooltip
     Display mechanism using tooltip for a list of possible completions.

NOTE: Add sections for writing new collectors.


File: semantic-appdev.info,  Node: Old Tag Completion,  Prev: Custom Tag Completion Functions,  Up: Tag Completion

Older Tag Completion functions
==============================

These are older completion functions.  They may still be useful.

 - Function: semantic-read-symbol prompt &optional default stream filter
     Read a symbol name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.  FILTER is provides
     a filter on the types of things to complete.  FILTER must be a
     function to call on each element.

 - Function: semantic-read-variable prompt &optional default stream
     Read a variable name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tokens to complete from.

 - Function: semantic-read-function prompt &optional default stream
     Read a function name from the user for the current buffer.  PROMPT
     is the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.

 - Function: semantic-read-type prompt &optional default stream
     Read a type name from the user for the current buffer.  PROMPT is
     the prompt to use.  Optional arguments: DEFAULT is the default
     choice.  If no default is given, one is read from under point.
     STREAM is the list of tags to complete from.


File: semantic-appdev.info,  Node: Override Methods,  Next: Parser Features,  Prev: Tag Completion,  Up: Top

Override Methods
****************

These functions are called `override methods' because they provide
generic behaviors, which a given language can override.  For example,
finding a dependency file in Emacs lisp can be done with the
`locate-library' command (which overrides the default behavior.)  In C,
a dependency can be found by searching a generic search path which can
be passed in via a variable.

If you plan to use one of these functions from a buffer that is not of
the same major-mode as the original tag, you can use this form to make
sure the correct action takes place:

 - Function: semantic-with-mode-bindings mode &rest body
     Evaluate BODY with the local bindings of MODE.  The current mode
     bindings are saved, BODY is evaluated, and the saved bindings are
     restored, even in case of an abnormal exit.  Value is what BODY
     returns.

For more on override methods, *note (lang-support-guide)Semantic
Overload Mechanism::.

* Menu:

* Format Tag::                  Converting Tokens into text strings
* Tag Members::                 Tags in tags
* Tag Details::                 Arbitrary token detail fetching
* Making New Methods::          How to add your own methods for a tool


File: semantic-appdev.info,  Node: Format Tag,  Next: Tag Members,  Up: Override Methods

Format Tag
==========

Any given tag consists of Meta information which is best viewed in some
textual form.  This could be as simple as the tag's name, or as a
prototype to be added to header file in C.  Not only are there several
default converters from a Tag into text, but there is also some
convenient variables that can be used with them.  Use these variables
to allow options on output forms when displaying tags in your programs.

 - Variable: semantic-format-tag-functions
     List of functions which convert a tag to text.  Each function must
     take the parameters TAG &optional PARENT COLOR.  TAG is the tag to
     convert.  PARENT is a parent tag or name which refers to the
     structure or class which contains TAG.  PARENT is NOT a class
     which a TAG would claim as a parent.  COLOR indicates that the
     generated text should be colored using `font-lock'.

 - Variable: semantic-format-tag-custom-list
     A List used by customizeable variables to choose a tag to text
     function.  Use this variable in the `:type' field of a
     customizable variable.

Every tag to text conversion function must take the same parameters,
which are TAG, the tag to be converted, PARENT, the containing parent
(like a structure which contains a variable), and COLOR, which is a
flag specifying that color should be applied to the returned string.

When creating, or using these strings, particularly with color, use
"concat" to build up larger strings instead of "format".  This will
preserve text properties.

 - Function: semantic-format-tag-name tag &optional parent color
     Return the name string describing TAG.  The name is the shortest
     possible representation.  Optional argument PARENT is the parent
     type if TAG is a detail.  Optional argument COLOR means highlight
     the prototype with font-lock colors.  This function can be
     overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-name' introduced in semantic
     version 2.0 supercedes `semantic-name-nonterminal' which is now
     obsolete.

 - Function: semantic-format-tag-abbreviate tag &optional parent color
     Return an abbreviated string describing TAG.  The abbreviation is
     to be short, with possible symbols indicating the type of tag, or
     other information.  Optional argument PARENT is the parent type if
     TAG is a detail.  Optional argument COLOR means highlight the
     prototype with font-lock colors.  This function can be overloaded
     (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-abbreviate' introduced in
     semantic version 2.0 supercedes `semantic-abbreviate-nonterminal'
     which is now obsolete.

 - Function: semantic-format-tag-summarize tag &optional parent color
     Summarize TAG in a reasonable way.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-summarize' introduced in
     semantic version 2.0 supercedes `semantic-summerize-nonterminal'
     which is now obsolete.

 - Function: semantic-format-tag-prototype tag &optional parent color
     Return a prototype for TAG.  This function should be overloaded,
     though it need not be used.  This is because it can be used to
     create code by language independent tools.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-prototype' introduced in
     semantic version 2.0 supercedes `semantic-prototype-nonterminal'
     which is now obsolete.

 - Function: semantic-format-tag-concise-prototype tag &optional parent
          color
     Return a concise prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-concise-prototype'
     introduced in semantic version 2.0 supercedes
     `semantic-concise-prototype-nonterminal' which is now obsolete.

 - Function: semantic-format-tag-uml-abbreviate tag &optional parent
          color
     Return a UML style abbreviation for TAG.  Optional argument PARENT
     is the parent type if TAG is a detail.  Optional argument COLOR
     means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-uml-abbreviate' introduced
     in semantic version 2.0 supercedes
     `semantic-uml-abbreviate-nonterminal' which is now obsolete.

 - Function: semantic-format-tag-uml-prototype tag &optional parent
          color
     Return a UML style prototype for TAG.  Optional argument PARENT is
     the parent type if TAG is a detail.  Optional argument COLOR means
     highlight the prototype with font-lock colors.  This function can
     be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-format-tag-uml-prototype' introduced in
     semantic version 2.0 supercedes
     `semantic-uml-prototype-nonterminal' which is now obsolete.

 - Function: semantic-format-tag-uml-concise-prototype tag &optional
          parent color
     Return a UML style concise prototype for TAG.  Optional argument
     PARENT is the parent type if TAG is a detail.  Optional argument
     COLOR means highlight the prototype with font-lock colors.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-format-tag-uml-concise-prototype'
     introduced in semantic version 2.0 supercedes
     `semantic-uml-concise-prototype-nonterminal' which is now obsolete.

 - Function: semantic-format-tag-prin1 tag &optional parent color
     Convert TAG to a string that is the print name for TAG.  PARENT
     and COLOR are ignored.

     *Compatibility*: `semantic-format-tag-prin1' introduced in
     semantic version 2.0 supercedes `semantic-prin1-nonterminal' which
     is now obsolete.

An additional utility will return a string for just the data type of a
tag.  This function is used in the above routines as well.

 - Function: semantic-format-tag-type tag color
     Convert the data type of TAG to a string usable in tag formatting.
     It is presumed that TYPE is a string or semantic tag.  This
     function can be overloaded (see "define-mode-local-override" for
     details).


File: semantic-appdev.info,  Node: Tag Members,  Next: Tag Details,  Prev: Format Tag,  Up: Override Methods

Tag Members
===========

Tags are often in a hierarchical form, meaning that a tag found in the
top-level list may itself contain additional members.

The following overridable functions can fetch those tags.

 - Function: semantic-tag-components tag
     Return a list of components for TAG.  A Component is a part of TAG
     which itself may be a TAG.  Examples include the elements of a
     structure in a tag of class `type, or the list of arguments to a
     tag of class `'function'.  This function can be overloaded (see
     "define-mode-local-override" for details).

 - Function: semantic-tag-components-with-overlays tag
     Return the list of top level components belonging to TAG.
     Children are any sub-tags which contain overlays.

     Default behavior is to get "semantic-tag-components" in addition
     to the components of an anonymous types (if applicable.)

     Note for language authors:   If a mode defines a language tag that
     has tags in it with overlays you should still return them with
     this function.  Ignoring this step will prevent several features
     from working correctly.  This function can be overloaded (see
     "define-mode-local-override" for details).

Some languages can define parts of a tag outside the actual scope of
the parent tag.  You can fetch information about them with these
overload functions.

 - Function: semantic-tag-external-member-p parent tag
     Return non-`nil' if PARENT is the parent of TAG.  TAG is an
     external member of PARENT when it is somehow tagged as having
     PARENT as it's parent.  PARENT and TAG must both be semantic tags.

     The default behavior, if not overridden with
     `tag-external-member-p' is to match `:parent' attribute in the
     name of TAG.

     If this function is overridden, use
     `semantic-tag-external-member-children-p-default' to also include
     the default behavior, and merely extend your own.  This function
     can be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-tag-external-member-p' introduced in
     semantic version 2.0 supercedes
     `semantic-nonterminal-external-member-p' which is now obsolete.

 - Function: semantic-tag-external-member-children tag &optional usedb
     Return the list of children which are not *in* TAG.  If optional
     argument USEDB is non-`nil', then also search files in the
     Semantic Database.  If USEDB is a list of databases, search those
     databases.

     Children in this case are functions or types which are members of
     TAG, such as the parts of a type, but which are not defined inside
     the class.  C++ and CLOS both permit methods of a class to be
     defined outside the bounds of the class' definition.

     The default behavior, if not overridden with
     `tag-external-member-children' is to search using
     "semantic-tag-external-member-p" in all top level definitions with
     a parent of TAG.

     If this function is overridden, use
     "semantic-tag-external-member-children-default" to also include
     the default behavior, and merely extend your own.  This function
     can be overloaded (see "define-mode-local-override" for details).

     *Compatibility*: `semantic-tag-external-member-children'
     introduced in semantic version 2.0 supercedes
     `semantic-nonterminal-external-member-children' which is now
     obsolete.


File: semantic-appdev.info,  Node: Tag Details,  Next: Making New Methods,  Prev: Tag Members,  Up: Override Methods

Tag Details
===========

These functions help derive information about tags that may not be
obvious for non-traditional languages with their own token types.

 - Function: semantic-tag-protection tag &optional parent
     Return protection information about TAG with optional PARENT.
     This function returns on of the following symbols:    `nil'
     - No special protection.  Language dependent.     `'public'    -
     Anyone can access this TAG.     `'private'   - Only methods in the
     local scope can access TAG.     `'protected' - Like private for
     outside scopes, like public for child                 classes.
     Some languages may choose to provide additional return symbols
     specific to themselves.  Use of this function should allow for
     this.

     The default behavior (if not overridden with `tag-protection' is
     to return a symbol based on type modifiers.  This function can be
     overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-nonterminal-protection" obsolete.

     *Compatibility*: `semantic-tag-protection' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-protection' which is
     now obsolete.

 - Function: semantic-tag-protected-p tag protection &optional parent
     Non-`nil' if TAG is is protected.  PROTECTION is a symbol which
     can be returned by the method "semantic-tag-protection".  PARENT
     is the parent data type which contains TAG.

     For these PROTECTIONs, true is returned if TAG is:
    `nil'
          Always true

    private
          True if `nil'.

    protected
          True if private or `nil'.

    public
          True if private, protected, or `nil'.

 - Function: semantic-tag-abstract-p tag &optional parent
     Return non `nil' if TAG is abstract.  Optional PARENT is the
     parent tag of TAG.  In UML, abstract methods and classes have
     special meaning and behavior in how methods are overridden.  In
     UML, abstract methods are italicized.

     The default behavior (if not overridden with `tag-abstract-p' is
     to return true if `abstract' is in the type modifiers.  This
     function can be overloaded (see "define-mode-local-override" for
     details).  It makes the overload "semantic-nonterminal-abstract"
     obsolete.

     *Compatibility*: `semantic-tag-abstract-p' introduced in semantic
     version 2.0 supercedes `semantic-nonterminal-abstract' which is
     now obsolete.

 - Function: semantic-tag-leaf-p tag &optional parent
     Return non `nil' if TAG is leaf.  Optional PARENT is the parent
     tag of TAG.  In UML, leaf methods and classes have special meaning
     and behavior.

     The default behavior (if not overridden with `tag-leaf-p' is to
     return true if `leaf' is in the type modifiers.  This function can
     be overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-nonterminal-leaf" obsolete.

     *Compatibility*: `semantic-tag-leaf-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-leaf' which is now obsolete.

 - Function: semantic-tag-static-p tag &optional parent
     Return non `nil' if TAG is static.  Optional PARENT is the parent
     tag of TAG.  In UML, static methods and attributes mean that they
     are allocated in the parent class, and are not instance specific.
     UML notation specifies that STATIC entries are underlined.  This
     function can be overloaded (see "define-mode-local-override" for
     details).

     *Compatibility*: `semantic-tag-static-p' introduced in semantic
     version 2.0 supercedes `semantic-tag-static' which is now obsolete.

 - Variable: semantic-dependency-include-path
     Defines the include path used when searching for files.  This
     should be a list of directories to search which is specific to the
     file being included.

     If "semantic-dependency-tag-file" is overridden for a given
     language, this path is most likely ignored.

     This function, reguardless of being overriden, caches the located
     dependency file location in the tag property `dependency-file'.
     If you override this function, you do not need to implement your
     own cache.  Each time the buffer is fully reparsed, the cache will
     be reset.

     TODO: use ffap.el to locate such items.

 - Function: semantic-dependency-tag-file &optional tag
     Find the filename represented from TAG.  Depends on
     `semantic-dependency-include-path' for searching.  Always searches
     `.' first, then searches additional paths.  This function can be
     overloaded (see "define-mode-local-override" for details).  It
     makes the overload "semantic-find-dependency" obsolete.

     *Compatibility*: `semantic-dependency-tag-file' introduced in
     semantic version 2.0 supercedes `semantic-find-dependency' which
     is now obsolete.

 - Function: semantic-prototype-file buffer
     Return a file in which prototypes belonging to BUFFER should be
     placed.  Default behavior (if not overridden) looks for a token
     specifying the prototype file, or the existence of an EDE variable
     indicating which file prototypes belong in.  This function can be
     overloaded (see "define-mode-local-override" for details).

 - Function: semantic-go-to-tag tag &optional parent
     Go to the location of TAG.  TAG may be a stripped element, in
     which case PARENT specifies a parent tag that has position
     information.  Different behaviors are provided depending on the
     type of tag.  For example, dependencies (includes) will seek out
     the file that is depended on (see "semantic-dependency-tag-file".
     This function can be overloaded (see "define-mode-local-override"
     for details).  It makes the overload "semantic-find-nonterminal"
     obsolete.

     *Compatibility*: `semantic-go-to-tag' introduced in semantic
     version 2.0 supercedes `semantic-find-nonterminal' which is now
     obsolete.

 - Function: semantic-texi-find-documentation name &optional type
     Find the function or variable NAME of TYPE in the texinfo source.
     NAME is a string representing some functional symbol.  TYPE is a
     string, such as "variable" or "Command" used to find the correct
     definition in case NAME qualifies as several things.  When this
     function exists, POINT is at the definition.  If the doc was not
     found, an error is thrown.  Note: TYPE not yet implemented.


File: semantic-appdev.info,  Node: Making New Methods,  Prev: Tag Details,  Up: Override Methods

Making New Methods
==================

To create your own application specific mode local function, you should
use "define-overload".  This function creates the framework needed for
different mode-authors to customize your applications.

Once a function has been defined as mode-local, you should use
"define-mode-local-override" to add a mode specific feature.

 - Function: define-overload name args docstring &rest body
     Define a new function, as with "defun" which can be overloaded.
     NAME is the name of the function to create.  ARGS are the
     arguments to the function.  DOCSTRING is a documentation string to
     describe the function.  The docstring will automatically had
     details about its overload symbol appended to the end.  BODY is
     code that would be run when there is no override defined.  The
     default is to call the function `NAME-default' with the appropriate
     arguments.

     BODY can also include an override form that specifies which part of
     BODY is specifically overridden.  This permits to specify common
     code run for both default and overridden implementations.  An
     override form is one of:

     1. (:override [OVERBODY])   2. (:override-with-args OVERARGS
     [OVERBODY])

     OVERBODY is the code that would be run when there is no override
     defined.  The default is to call the function `NAME-default' with
     the appropriate arguments deduced from ARGS.  OVERARGS is a list
     of arguments passed to the override and `NAME-default' function,
     in place of those deduced from ARGS.

 - Function: define-mode-local-override name mode args docstring &rest
          body
     Define a mode specific override of the function overload NAME.
     Has meaning only if NAME has been created with "define-overload".
     MODE is the major mode this override is being defined for.  ARGS
     are the function arguments, which should match those of the same
     named function created with "define-overload".  DOCSTRING is the
     documentation string.  BODY is the implementation of this function.

     *Compatibility*: `define-mode-local-override' introduced in
     semantic version 2.0 supercedes
     `define-mode-overload-implementation' which is now obsolete.


File: semantic-appdev.info,  Node: Parser Features,  Next: Semantic Database,  Prev: Override Methods,  Up: Top

Parser Features
***************

If you write a program that uses a tag table in a persistent display or
database, it is necessary to know when tag tables change so that your
displays can be updated.  This is especially important as tags can be
replaced, changed, or deleted, and the associated overlays will then
throw errors when you try to use them.  Complete integration with tag
changes can be achieved via several hooks.

If you write an application that frequenly accesses the tags tables, it
is important to make sure those tags are up to date, and to make sure
you application does not adversely effect all the other minor modes
that may be running.

The semantic parser has many features and hooks that applications can
use to provide a good user experience.

* Menu:

* Editing Buffers::             Let the parser know you are changing a buffer.
* Parser State::                Knowing if the tag table is out of date
* Parser Hooks::                Knowing when tags change
* Lexical Safety::              Preventing lexical errors from making a mess


File: semantic-appdev.info,  Node: Editing Buffers,  Next: Parser State,  Up: Parser Features

Editing Buffers
===============

One interesting way to interact with the parser is to let it know that
changes you are going to make will not require re-parsing.

 - Variable: semantic-edits-are-safe
     When non-`nil', modifications do not require a reparse.  This
     prevents tokens from being marked dirty, and it prevents top level
     edits from causing a cache check.  Use this when writing programs
     that could cause a full reparse, but will not change the tag
     structure, such as adding or updating top-level comments.


File: semantic-appdev.info,  Node: Parser State,  Next: Parser Hooks,  Prev: Editing Buffers,  Up: Parser Features

Parser State
============

It is sometimes useful to know what the current parsing state is.
These function can let you know what level of re-parsing may be needed.
Careful choices on when to reparse can make your program much faster.

 - Function: semantic-parse-tree-needs-update-p
     Return non-`nil' if the current parse tree needs to be updated.

 - Function: semantic-parse-tree-needs-rebuild-p
     Return non-`nil' if the current parse tree needs to be rebuilt.

 - Function: semantic-parse-tree-unparseable-p
     Return non-`nil' if the current buffer has been marked unparseable.

 - Function: semantic-parse-tree-up-to-date-p
     Return non-`nil' if the current parse tree is up to date.


File: semantic-appdev.info,  Node: Parser Hooks,  Next: Lexical Safety,  Prev: Parser State,  Up: Parser Features

Parser Hooks
============

If you just want to know when a buffer changes, use this hook.

 - Variable: semantic-after-toplevel-cache-change-hook
     Hooks run after the buffer tag list has changed.  This list will
     change when a buffer is reparsed, or when the tag list in a buffer
     is cleared.  It is *NOT* called if the current tag list is
     partially reparsed.

     Hook functions must take one argument, which is the new list of
     tags associated with this buffer.

     For language specific hooks, make sure you define this as a local
     hook.

If you want tighter interaction with how the user is editing different
tags, you can use this hook instead.

 - Variable: semantic-after-partial-cache-change-hook
     Hooks run after the buffer cache has been updated.

     This hook will run when the cache has been partially reparsed.
     Partial reparses are incurred when a user edits a buffer, and only
     the modified sections are rescanned.

     Hook functions must take one argument, which is the list of tokens
     updated in the current buffer.

     For language specific hooks, make sure you define this as a local
     hook.

It is also useful to clean up any data your application is using when
semantic flushes its tags table.

 - Variable: semantic-before-toplevel-cache-flush-hook
     Hooks run before the toplevel nonterminal cache is flushed.  For
     language specific hooks, make sure you define this as a local
     hook.  This hook is called before a corresponding
     `semantic-after-toplevel-cache-change-hook' which is also called
     during a flush when the cache is given a new value of `nil'.

